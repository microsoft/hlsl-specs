<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>High-Level Shader Language Specification Working Draft</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">High-Level Shader Language Specification<br />
<span>Working Draft</span></h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#Intro" id="toc-Intro">Introduction[Intro]</a>
<ul>
<li><a href="#Intro.Scope"
id="toc-Intro.Scope">Scope[Intro.Scope]</a></li>
<li><a href="#Intro.Refs" id="toc-Intro.Refs">Normative
References[Intro.Refs]</a></li>
<li><a href="#Intro.Terms" id="toc-Intro.Terms">Terms and
definitions[Intro.Terms]</a></li>
<li><a href="#Intro.Defs" id="toc-Intro.Defs">Common
Definitions[Intro.Defs]</a>
<ul>
<li><a href="#Intro.Defs.CorrectData"
id="toc-Intro.Defs.CorrectData">Correct
Data[Intro.Defs.CorrectData]</a></li>
<li><a href="#Intro.Defs.Diags" id="toc-Intro.Defs.Diags">Diagnostic
Message[Intro.Defs.Diags]</a></li>
<li><a href="#Intro.Defs.IllFormed"
id="toc-Intro.Defs.IllFormed">Ill-formed
Program[Intro.Defs.IllFormed]</a></li>
<li><a href="#Intro.Defs.ImpDef"
id="toc-Intro.Defs.ImpDef">Implementation-defined
Behavior[Intro.Defs.ImpDef]</a></li>
<li><a href="#Intro.Defs.ImpLimits"
id="toc-Intro.Defs.ImpLimits">Implementation
Limits[Intro.Defs.ImpLimits]</a></li>
<li><a href="#Intro.Defs.Undefined"
id="toc-Intro.Defs.Undefined">Undefined
Behavior[Intro.Defs.Undefined]</a></li>
<li><a href="#Intro.Defs.Unspecified"
id="toc-Intro.Defs.Unspecified">Unspecified
Behavior[Intro.Defs.Unspecified]</a></li>
<li><a href="#Intro.Defs.WellFormed"
id="toc-Intro.Defs.WellFormed">Well-formed
Program[Intro.Defs.WellFormed]</a></li>
<li><a href="#Intro.Defs.Runtime" id="toc-Intro.Defs.Runtime">Runtime
Implementation[Intro.Defs.Runtime]</a></li>
</ul></li>
<li><a href="#Intro.Runtime" id="toc-Intro.Runtime">Runtime
Targeting[Intro.Runtime]</a></li>
<li><a href="#Intro.Model" id="toc-Intro.Model"><span
data-acronym-label="spmd" data-acronym-form="singular+long">spmd</span>
Programming Model[Intro.Model]</a>
<ul>
<li><a href="#Intro.Model.Terms" id="toc-Intro.Model.Terms"><span
data-acronym-label="spmd" data-acronym-form="singular+abbrv">spmd</span>
Terminology[Intro.Model.Terms]</a></li>
<li><a href="#Intro.Model.Exec" id="toc-Intro.Model.Exec"><span
data-acronym-label="spmd" data-acronym-form="singular+abbrv">spmd</span>
Execution Model[Intro.Model.Exec]</a></li>
<li><a href="#Intro.Model.Restrictions"
id="toc-Intro.Model.Restrictions">Optimization
Restrictions[Intro.Model.Restrictions]</a></li>
</ul></li>
<li><a href="#Intro.Memory" id="toc-Intro.Memory"><span
data-acronym-label="hlsl" data-acronym-form="singular+abbrv">hlsl</span>
Memory Models[Intro.Memory]</a>
<ul>
<li><a href="#Intro.Memory.Spaces" id="toc-Intro.Memory.Spaces">Memory
Spaces[Intro.Memory.Spaces]</a></li>
<li><a href="#Intro.Memory.Alignment"
id="toc-Intro.Memory.Alignment">Memory
Spaces[Intro.Memory.Alignment]</a></li>
</ul></li>
</ul></li>
<li><a href="#Lex" id="toc-Lex">Lexical Conventions[Lex]</a>
<ul>
<li><a href="#Lex.Translation" id="toc-Lex.Translation">Unit of
Translation[Lex.Translation]</a></li>
<li><a href="#Lex.Phases" id="toc-Lex.Phases">Phases of
Translation[Lex.Phases]</a></li>
<li><a href="#Lex.CharSet" id="toc-Lex.CharSet">Character
Sets[Lex.CharSet]</a></li>
<li><a href="#Lex.PPTokens" id="toc-Lex.PPTokens">Preprocessing
Tokens[Lex.PPTokens]</a></li>
<li><a href="#Lex.Tokens"
id="toc-Lex.Tokens">Tokens[Lex.Tokens]</a></li>
<li><a href="#Lex.Comments"
id="toc-Lex.Comments">Comments[Lex.Comments]</a></li>
<li><a href="#Lex.Headers" id="toc-Lex.Headers">Header
Names[Lex.Headers]</a></li>
<li><a href="#Lex.PPNumber" id="toc-Lex.PPNumber">Preprocessing
numbers[Lex.PPNumber]</a></li>
<li><a href="#Lex.Literals"
id="toc-Lex.Literals">Literals[Lex.Literals]</a>
<ul>
<li><a href="#Lex.Literal.Kinds" id="toc-Lex.Literal.Kinds">Literal
Classifications[Lex.Literal.Kinds]</a></li>
<li><a href="#Lex.Literal.Int" id="toc-Lex.Literal.Int">Integer
Literals[Lex.Literal.Int]</a></li>
<li><a href="#Lex.Literal.Float"
id="toc-Lex.Literal.Float">Floating-point
Literals[Lex.Literal.Float]</a></li>
<li><a href="#Lex.Literal.Vector" id="toc-Lex.Literal.Vector">Vector
Literals[Lex.Literal.Vector]</a></li>
</ul></li>
</ul></li>
<li><a href="#Basic" id="toc-Basic">Basic Concepts[Basic]</a>
<ul>
<li><a href="#Basic.preamble"
id="toc-Basic.preamble">Preamble[Basic.preamble]</a></li>
<li><a href="#Basic.Decl" id="toc-Basic.Decl">Declarations and
definitions[Basic.Decl]</a></li>
<li><a href="#Basic.ODR" id="toc-Basic.ODR">One-Definition
Rule[Basic.ODR]</a></li>
<li><a href="#Basic.Scope"
id="toc-Basic.Scope">Scope[Basic.Scope]</a></li>
<li><a href="#Basic.Lookup" id="toc-Basic.Lookup">Name
Lookup[Basic.Lookup]</a></li>
<li><a href="#Basic.Linkage" id="toc-Basic.Linkage">Program and
linkage[Basic.Linkage]</a>
<ul>
<li><a href="#Basic.Linkage.Program"
id="toc-Basic.Linkage.Program">Program
Linkage[Basic.Linkage.Program]</a></li>
<li><a href="#Basic.Linkage.External"
id="toc-Basic.Linkage.External">External
Linkage[Basic.Linkage.External]</a></li>
<li><a href="#Basic.Linkage.Internal"
id="toc-Basic.Linkage.Internal">Internal
Linkage[Basic.Linkage.Internal]</a></li>
<li><a href="#Basic.Linkage.NoLinkage"
id="toc-Basic.Linkage.NoLinkage">No
Linkage[Basic.Linkage.NoLinkage]</a></li>
</ul></li>
<li><a href="#Basic.Start" id="toc-Basic.Start">Start[Basic.Start]</a>
<ul>
<li><a href="#Basic.Start.Mode" id="toc-Basic.Start.Mode">Execution
Mode[Basic.Start.Mode]</a></li>
</ul></li>
<li><a href="#Basic.types" id="toc-Basic.types">Types[Basic.types]</a>
<ul>
<li><a href="#Basic.types.arithmetic"
id="toc-Basic.types.arithmetic">Arithmetic
Types[Basic.types.arithmetic]</a></li>
<li><a href="#Basic.types.scalarized"
id="toc-Basic.types.scalarized">Scalarized Type
Compatability[Basic.types.scalarized]</a></li>
<li><a href="#Basic.types.intangible"
id="toc-Basic.types.intangible">Usage of Intangible
Types[Basic.types.intangible]</a></li>
</ul></li>
<li><a href="#Basic.lval" id="toc-Basic.lval">Lvalues and
rvalues[Basic.lval]</a></li>
</ul></li>
<li><a href="#Conv" id="toc-Conv">Standard Conversions[Conv]</a>
<ul>
<li><a href="#Conv.lval" id="toc-Conv.lval">Lvalue-to-rvalue
conversion[Conv.lval]</a></li>
<li><a href="#Conv.array" id="toc-Conv.array">Array-to-pointer
conversion[Conv.array]</a></li>
<li><a href="#Conv.ipromote" id="toc-Conv.ipromote">Integral
promotion[Conv.ipromote]</a></li>
<li><a href="#Conv.fppromote" id="toc-Conv.fppromote">Floating point
promotion[Conv.fppromote]</a></li>
<li><a href="#Conv.iconv" id="toc-Conv.iconv">Integral
conversion[Conv.iconv]</a></li>
<li><a href="#Conv.fconv" id="toc-Conv.fconv">Floating point
conversion[Conv.fconv]</a></li>
<li><a href="#Conv.fpint" id="toc-Conv.fpint">Floating point-integral
conversion[Conv.fpint]</a></li>
<li><a href="#Conv.bool" id="toc-Conv.bool">Boolean
conversion[Conv.bool]</a></li>
<li><a href="#Conv.flat" id="toc-Conv.flat">Elementwise
conversion[Conv.flat]</a></li>
<li><a href="#Conv.vsplat" id="toc-Conv.vsplat">Vector splat
conversion[Conv.vsplat]</a></li>
<li><a href="#Conv.asplat" id="toc-Conv.asplat">Array and Class splat
conversion[Conv.asplat]</a></li>
<li><a href="#Conv.vtrunc" id="toc-Conv.vtrunc">Vector and matrix
truncation conversion[Conv.vtrunc]</a></li>
<li><a href="#Conv.cwise" id="toc-Conv.cwise">Component-wise
conversions[Conv.cwise]</a></li>
<li><a href="#Conv.qual" id="toc-Conv.qual">Qualification
conversion[Conv.qual]</a></li>
<li><a href="#Conv.rank" id="toc-Conv.rank">Conversion
Rank[Conv.rank]</a>
<ul>
<li><a href="#Conv.rank.int" id="toc-Conv.rank.int">Integer Conversion
Rank[Conv.rank.int]</a></li>
<li><a href="#Conv.rank.float" id="toc-Conv.rank.float">Floating Point
Conversion Rank[Conv.rank.float]</a></li>
</ul></li>
</ul></li>
<li><a href="#Expr" id="toc-Expr">Expressions[Expr]</a>
<ul>
<li><a href="#Expr.conv" id="toc-Expr.conv">Usual Arithmetic
Conversions[Expr.conv]</a></li>
<li><a href="#Expr.Primary" id="toc-Expr.Primary">Primary
Expressions[Expr.Primary]</a>
<ul>
<li><a href="#Expr.Primary.Literal"
id="toc-Expr.Primary.Literal">Literals[Expr.Primary.Literal]</a></li>
<li><a href="#Expr.Primary.This"
id="toc-Expr.Primary.This">This[Expr.Primary.This]</a></li>
<li><a href="#Expr.Primary.Paren"
id="toc-Expr.Primary.Paren">Parenthesis[Expr.Primary.Paren]</a></li>
<li><a href="#Expr.Primary.ID"
id="toc-Expr.Primary.ID">Names[Expr.Primary.ID]</a></li>
</ul></li>
<li><a href="#Expr.Post" id="toc-Expr.Post">Postfix
Expressions[Expr.Post]</a></li>
<li><a href="#Expr.Post.Subscript"
id="toc-Expr.Post.Subscript">Subscript[Expr.Post.Subscript]</a></li>
<li><a href="#Expr.Post.Call" id="toc-Expr.Post.Call">Function
Calls[Expr.Post.Call]</a></li>
</ul></li>
<li><a href="#Stmt" id="toc-Stmt">Statements[Stmt]</a>
<ul>
<li><a href="#Stmt.Label" id="toc-Stmt.Label">Label
Statements[Stmt.Label]</a></li>
<li><a href="#Stmt.Attr" id="toc-Stmt.Attr">Attributes[Stmt.Attr]</a>
<ul>
<li><a href="#Stmt.Attr.Unroll" id="toc-Stmt.Attr.Unroll">Unroll
Attribute[Stmt.Attr.Unroll]</a></li>
<li><a href="#Stmt.Attr.Loop" id="toc-Stmt.Attr.Loop">Loop
Attribute[Stmt.Attr.Loop]</a></li>
</ul></li>
</ul></li>
<li><a href="#Decl" id="toc-Decl">Declarations[Decl]</a>
<ul>
<li><a href="#Decl.Pre" id="toc-Decl.Pre">Preamble[Decl.Pre]</a></li>
<li><a href="#Decl.Spec" id="toc-Decl.Spec">Specifiers[Decl.Spec]</a>
<ul>
<li><a href="#Decl.Spec.General"
id="toc-Decl.Spec.General">General[Decl.Spec.General]</a></li>
<li><a href="#Decl.Spec.Fct" id="toc-Decl.Spec.Fct">Function
specifiers[Decl.Spec.Fct]</a></li>
</ul></li>
<li><a href="#Decl.Decl"
id="toc-Decl.Decl">Declarators[Decl.Decl]</a></li>
<li><a href="#Decl.Init" id="toc-Decl.Init">Initializers[Decl.Init]</a>
<ul>
<li><a href="#Decl.Init.Agg" id="toc-Decl.Init.Agg">Aggregate
Initialization[Decl.Init.Agg]</a></li>
</ul></li>
<li><a href="#Decl.Function" id="toc-Decl.Function">Function
Definitions[Decl.Function]</a></li>
<li><a href="#Decl.Attr" id="toc-Decl.Attr">Attributes[Decl.Attr]</a>
<ul>
<li><a href="#Decl.Attr.Semantic" id="toc-Decl.Attr.Semantic">Semantic
Annotations[Decl.Attr.Semantic]</a></li>
<li><a href="#Decl.Attr.Entry" id="toc-Decl.Attr.Entry">Entry
Attributes[Decl.Attr.Entry]</a></li>
</ul></li>
<li><a href="#Decl.Export" id="toc-Decl.Export">Export
Declarations[Decl.Export]</a></li>
</ul></li>
<li><a href="#Overload" id="toc-Overload">Overloading[Overload]</a>
<ul>
<li><a href="#Overload.Decl" id="toc-Overload.Decl">Overloadable
Declarations[Overload.Decl]</a></li>
<li><a href="#Overload.Res" id="toc-Overload.Res">Overload
Resolution[Overload.Res]</a>
<ul>
<li><a href="#Overload.Res.Sets" id="toc-Overload.Res.Sets">Candidate
Functions and Argument Lists[Overload.Res.Sets]</a></li>
<li><a href="#Overload.Res.Viable" id="toc-Overload.Res.Viable">Viable
Functions[Overload.Res.Viable]</a></li>
<li><a href="#Overload.Res.Best" id="toc-Overload.Res.Best">Best Viable
Function[Overload.Res.Best]</a></li>
<li><a href="#Overload.ICS" id="toc-Overload.ICS">Implicit Conversion
Sequences[Overload.ICS]</a></li>
</ul></li>
</ul></li>
<li><a href="#Resources" id="toc-Resources">Resource
Types[Resources]</a>
<ul>
<li><a href="#Resources.tybufs" id="toc-Resources.tybufs">Typed
Buffers[Resources.tybufs]</a>
<ul>
<li><a href="#Resources.tybufs.ctrs"
id="toc-Resources.tybufs.ctrs">Constructors[Resources.tybufs.ctrs]</a></li>
<li><a href="#Resources.tybufs.dims"
id="toc-Resources.tybufs.dims">Dimensions[Resources.tybufs.dims]</a></li>
<li><a href="#Resources.tybufs.access"
id="toc-Resources.tybufs.access">Element
Access[Resources.tybufs.access]</a></li>
</ul></li>
<li><a href="#Resources.rawbufs" id="toc-Resources.rawbufs">Raw
Buffers[Resources.rawbufs]</a></li>
<li><a href="#Resources.babufs" id="toc-Resources.babufs">Byte Access
Buffers[Resources.babufs]</a>
<ul>
<li><a href="#Resources.babufs.ctrs"
id="toc-Resources.babufs.ctrs">Constructors[Resources.babufs.ctrs]</a></li>
<li><a href="#Resources.babufs.dims"
id="toc-Resources.babufs.dims">Dimensions[Resources.babufs.dims]</a></li>
<li><a href="#Resources.babufs.access"
id="toc-Resources.babufs.access">Element
Access[Resources.babufs.access]</a></li>
<li><a href="#Resources.babufs.atomics"
id="toc-Resources.babufs.atomics">Atomic
Operations[Resources.babufs.atomics]</a></li>
</ul></li>
<li><a href="#Resources.stbufs" id="toc-Resources.stbufs">Structured
Buffers[Resources.stbufs]</a>
<ul>
<li><a href="#Resources.stbufs.ctrs"
id="toc-Resources.stbufs.ctrs">Constructors[Resources.stbufs.ctrs]</a></li>
<li><a href="#Resources.stbufs.dims"
id="toc-Resources.stbufs.dims">Dimensions[Resources.stbufs.dims]</a></li>
<li><a href="#Resources.stbufs.access"
id="toc-Resources.stbufs.access">Element
Access[Resources.stbufs.access]</a></li>
<li><a href="#Resources.stbufs.counter"
id="toc-Resources.stbufs.counter">Counter
Manipulation[Resources.stbufs.counter]</a></li>
<li><a href="#Resources.stbufs.append"
id="toc-Resources.stbufs.append">Append[Resources.stbufs.append]</a></li>
<li><a href="#Resources.cnstbufs.consume"
id="toc-Resources.cnstbufs.consume">Consume[Resources.cnstbufs.consume]</a></li>
</ul></li>
<li><a href="#Resources.cnbuf" id="toc-Resources.cnbuf">Constant
Buffers[Resources.cnbuf]</a>
<ul>
<li><a href="#Resources.cnbuf.cb" id="toc-Resources.cnbuf.cb">Constant
Buffer Declaration Block[Resources.cnbuf.cb]</a></li>
<li><a href="#Resources.cnbuf.cbclass"
id="toc-Resources.cnbuf.cbclass">Constant Buffer
Class[Resources.cnbuf.cbclass]</a></li>
<li><a href="#Resources.cnbuf.lay" id="toc-Resources.cnbuf.lay">Constant
Buffer Layout[Resources.cnbuf.lay]</a></li>
<li><a href="#Resources.cnbuf.po" id="toc-Resources.cnbuf.po">Packoffset
annotations[Resources.cnbuf.po]</a></li>
<li><a href="#Resources.cnbuf.defcb"
id="toc-Resources.cnbuf.defcb">Default Constant
Buffer[Resources.cnbuf.defcb]</a></li>
</ul></li>
<li><a href="#Resources.samp"
id="toc-Resources.samp">Samplers[Resources.samp]</a></li>
<li><a href="#Resources.mapcheck"
id="toc-Resources.mapcheck">CheckAccessFullyMapped[Resources.mapcheck]</a></li>
<li><a href="#Resources.binding" id="toc-Resources.binding">Resource
Binding[Resources.binding]</a></li>
</ul></li>
<li><a href="#Classes" id="toc-Classes">Classes[Classes]</a>
<ul>
<li><a href="#Classes.Static" id="toc-Classes.Static">Static
Members[Classes.Static]</a></li>
<li><a href="#Classes.Conversions"
id="toc-Classes.Conversions">Conversions[Classes.Conversions]</a></li>
</ul></li>
<li><a href="#Template" id="toc-Template">Templates[Template]</a>
<ul>
<li><a href="#Template.Inst" id="toc-Template.Inst">Template
Instantiation[Template.Inst]</a></li>
<li><a href="#Template.Func.Order" id="toc-Template.Func.Order">Partial
Ordering of Function Templates[Template.Func.Order]</a></li>
</ul></li>
<li><a href="#Intangible" id="toc-Intangible">Intangible
Types[Intangible]</a></li>
<li><a href="#Runtime" id="toc-Runtime">Runtime[Runtime]</a></li>
</ul>
</nav>
<h1 id="Intro">Introduction[Intro]</h1>
<p><strong></strong> The <span data-acronym-label="hlsl"
data-acronym-form="singular+full">hlsl</span> is the GPU programming
language provided in conjunction with the <span data-acronym-label="dx"
data-acronym-form="singular+short">dx</span> runtime. Over many years
its use has expanded to cover every major rendering API across all major
development platforms. Despite its popularity and long history <span
data-acronym-label="hlsl" data-acronym-form="singular+abbrv">hlsl</span>
has never had a formal language specification. This document seeks to
change that.</p>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> draws heavy inspiration
originally from <span data-acronym-label="isoC"
data-acronym-form="singular+short">isoC</span> and later from <span
data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span> with additions specific
to graphics and parallel computation programming. The language is also
influenced to a lesser degree by other popular graphics and parallel
programming languages.</p>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> has two reference
implementations which this specification draws heavily from. The
original reference implementation <span data-acronym-label="fxc"
data-acronym-form="singular+full">fxc</span> has been in use since <span
data-acronym-label="dx" data-acronym-form="singular+short">dx</span> 9.
The more recent reference implementation <span data-acronym-label="dxc"
data-acronym-form="singular+full">dxc</span> has been the primary shader
compiler since <span data-acronym-label="dx"
data-acronym-form="singular+short">dx</span> 12.</p>
<p><strong></strong> In writing this specification bias is leaned toward
the language behavior of <span data-acronym-label="dxc"
data-acronym-form="singular+abbrv">dxc</span> rather than the behavior
of <span data-acronym-label="fxc"
data-acronym-form="singular+abbrv">fxc</span>, although that can vary by
context.</p>
<p><strong></strong> In very rare instances this spec will be
aspirational, and may diverge from both reference implementation
behaviors. This will only be done in instances where there is an intent
to alter implementation behavior in the future. Since this document and
the implementations are living sources, one or the other may be ahead in
different regards at any point in time.</p>
<h2 id="Intro.Scope">Scope[Intro.Scope]</h2>
<p><strong></strong> This document specifies the requirements for
implementations of <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span>. The <span
data-acronym-label="hlsl" data-acronym-form="singular+abbrv">hlsl</span>
specification is based on and highly influenced by the specifications
for the <span data-acronym-label="c"
data-acronym-form="singular+full">c</span> and the <span
data-acronym-label="cpp"
data-acronym-form="singular+full">cpp</span>.</p>
<p><strong></strong> This document covers both describing the language
grammar and semantics for <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span>, and (in later sections)
the standard library of data types used in shader programming.</p>
<h2 id="Intro.Refs">Normative References[Intro.Refs]</h2>
<p><strong></strong> The following referenced documents provide
significant influence on this document and should be used in conjunction
with interpreting this standard.</p>
<ul>
<li><p><span data-acronym-label="isoC"
data-acronym-form="singular+short">isoC</span>, <em>Programming
languages - C</em></p></li>
<li><p><span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span>, <em>Programming
languages - C++</em></p></li>
<li><p><span data-acronym-label="dx"
data-acronym-form="singular+short">dx</span> Specifications,
<em>https://microsoft.github.io/DirectX-Specs/</em></p></li>
</ul>
<h2 id="Intro.Terms">Terms and definitions[Intro.Terms]</h2>
<p><strong></strong> This document aims to use terms consistent with
their definitions in <span data-acronym-label="isoC"
data-acronym-form="singular+short">isoC</span> and <span
data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span>. In cases where the
definitions are unclear, or where this document diverges from <span
data-acronym-label="isoC" data-acronym-form="singular+short">isoC</span>
and <span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span>, the definitions in
this section, the remaining sections in this chapter, and the attached
glossary (<a href="#main" data-reference-type="ref"
data-reference="main">[main]</a>) supersede other sources.</p>
<h2 id="Intro.Defs">Common Definitions[Intro.Defs]</h2>
<p><strong></strong> The following definitions are consistent between
<span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> and the <span
data-acronym-label="isoC" data-acronym-form="singular+short">isoC</span>
and <span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span> specifications, however
they are included here for reader convenience.</p>
<h3 id="Intro.Defs.CorrectData">Correct
Data[Intro.Defs.CorrectData]</h3>
<p><strong></strong> Data is correct if it represents values that have
specified or unspecified but not undefined behavior for all the
operations in which it is used. Data that is the result of undefined
behavior is not correct, and may be treated as undefined.</p>
<h3 id="Intro.Defs.Diags">Diagnostic Message[Intro.Defs.Diags]</h3>
<p><strong></strong> An implementation defined message belonging to a
subset of the implementation’s output messages which communicates
diagnostic information to the user.</p>
<h3 id="Intro.Defs.IllFormed">Ill-formed
Program[Intro.Defs.IllFormed]</h3>
<p><strong></strong> A program that is not well-formed, for which the
implementation is expected to return unsuccessfully and produce one or
more diagnostic messages.</p>
<h3 id="Intro.Defs.ImpDef">Implementation-defined
Behavior[Intro.Defs.ImpDef]</h3>
<p><strong></strong> Behavior of a well-formed program and correct data
which may vary by the implementation, and the implementation is expected
to document the behavior.</p>
<h3 id="Intro.Defs.ImpLimits">Implementation
Limits[Intro.Defs.ImpLimits]</h3>
<p><strong></strong> Restrictions imposed upon programs by the
implementation of either the compiler or runtime environment. The
compiler may seek to surface runtime-imposed limits to the user for
improved user experience.</p>
<h3 id="Intro.Defs.Undefined">Undefined
Behavior[Intro.Defs.Undefined]</h3>
<p><strong></strong> Behavior of invalid program constructs or incorrect
data for which this standard imposes no requirements, or does not
sufficiently detail.</p>
<h3 id="Intro.Defs.Unspecified">Unspecified
Behavior[Intro.Defs.Unspecified]</h3>
<p><strong></strong> Behavior of a well-formed program and correct data
which may vary by the implementation, and the implementation is not
expected to document the behavior.</p>
<h3 id="Intro.Defs.WellFormed">Well-formed
Program[Intro.Defs.WellFormed]</h3>
<p><strong></strong> An <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> program constructed
according to the syntax rules, diagnosable semantic rules, and the One
Definition Rule.</p>
<h3 id="Intro.Defs.Runtime">Runtime
Implementation[Intro.Defs.Runtime]</h3>
<p><strong></strong> A runtime implementation refers to a full-stack
implementation of a software runtime that can facilitate the execution
of <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> programs. This broad
definition includes libraries and device driver implementations. The
<span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> specification does not
distinguish between the user-facing programming interfaces and the
vendor-specific backing implementation.</p>
<h2 id="Intro.Runtime">Runtime Targeting[Intro.Runtime]</h2>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> emerged from the
evolution of <span data-acronym-label="dx"
data-acronym-form="singular+short">dx</span> to grant greater control
over GPU geometry and color processing. It gained popularity because it
targeted a common hardware description which all conforming drivers were
required to support. This common hardware description, called a <span
data-acronym-label="sm" data-acronym-form="singular+short">sm</span>, is
an integral part of the description for <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> . Some <span
data-acronym-label="hlsl" data-acronym-form="singular+abbrv">hlsl</span>
features require specific <span data-acronym-label="sm"
data-acronym-form="singular+short">sm</span> features, and are only
supported by compilers when targeting those <span
data-acronym-label="sm" data-acronym-form="singular+short">sm</span>
versions or later.</p>
<h2 id="Intro.Model"><span data-acronym-label="spmd"
data-acronym-form="singular+long">spmd</span> Programming
Model[Intro.Model]</h2>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> uses a <span
data-acronym-label="spmd" data-acronym-form="singular+full">spmd</span>
programming model where a program describes operations on a single
element of data, but when the program executes it executes across more
than one element at a time. This programming model is useful due to GPUs
largely being <span data-acronym-label="simd"
data-acronym-form="singular+full">simd</span> hardware architectures
where each instruction natively executes across multiple data elements
at the same time.</p>
<p><strong></strong> There are many different terms of art for
describing the elements of a GPU architecture and the way they relate to
the <span data-acronym-label="spmd"
data-acronym-form="singular+abbrv">spmd</span> program model. In this
document we will use the terms as defined in the following
subsections.</p>
<h3 id="Intro.Model.Terms"><span data-acronym-label="spmd"
data-acronym-form="singular+abbrv">spmd</span>
Terminology[Intro.Model.Terms]</h3>
<h4 id="Intro.Model.Terms.HostDevice">Host and
Device[Intro.Model.Terms.HostDevice]</h4>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> is a data-parallel
programming language designed for programming auxiliary processors in a
larger system. In this context the <em>host</em> refers to the primary
processing unit that runs the application which in turn uses a runtime
to execute <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> programs on a supported
<em>device</em>. There is no strict requirement that the host and device
be different physical hardware, although they commonly are. The
separation of host and device in this specification is useful for
defining the execution and memory model as well as specific semantics of
language constructs.</p>
<h4 id="Intro.Model.Terms.Lane"><span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>[Intro.Model.Terms.Lane]</h4>
<p><strong></strong> A <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span> represents a single
computed element in an <span data-acronym-label="spmd"
data-acronym-form="singular+abbrv">spmd</span> program. In a traditional
programming model it would be analogous to a thread of execution,
however it differs in one key way. In multi-threaded programming threads
advance independent of each other. In <span data-acronym-label="spmd"
data-acronym-form="singular+abbrv">spmd</span> programs, a group of
<span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s may execute instructions
in lockstep because each instruction may be a <span
data-acronym-label="simd" data-acronym-form="singular+abbrv">simd</span>
instruction computing the results for multiple <span
data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s simultaneously, or
synchronizing execution across multiple <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s or <span
data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>s. A <span
data-acronym-label="lane" data-acronym-form="singular+short">lane</span>
has an associated <em>lane state</em> which denotes the execution status
of the lane (<a href="#Intro.Model.Terms.LaneState"
data-reference-type="ref"
data-reference="Intro.Model.Terms.LaneState">1.6.1.7</a>).</p>
<h4 id="Intro.Model.Terms.Wave"><span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>[Intro.Model.Terms.Wave]</h4>
<p><strong></strong> A grouping of <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s for execution is called
a <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>. The size of a <span
data-acronym-label="wave" data-acronym-form="singular+short">wave</span>
is defined as the maximum number of <em>active</em> <span
data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s the <span
data-acronym-label="wave" data-acronym-form="singular+short">wave</span>
supports. <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span> sizes vary by hardware
architecture, and are required to be powers of two. The number of
<em>active</em> <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s in a <span
data-acronym-label="wave" data-acronym-form="singular+short">wave</span>
can be any value between one and the <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span> size.</p>
<p><strong></strong> Some hardware implementations support multiple
<span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span> sizes. There is no
overall minimum wave size requirement, although some language features
do have minimum <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span> size requirements.</p>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> is explicitly designed to
run on hardware with arbitrary <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span> sizes. Hardware
architectures may implement <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>s as <span
data-acronym-label="simt" data-acronym-form="singular+full">simt</span>
where each thread executes instructions in lockstep. This is not a
requirement of the model. Some constructs in <span
data-acronym-label="hlsl" data-acronym-form="singular+abbrv">hlsl</span>
require synchronized execution. Such constructs will explicitly specify
that requirement.</p>
<h4 id="Intro.Model.Terms.Quad"><span data-acronym-label="quad"
data-acronym-form="singular+short">quad</span>[Intro.Model.Terms.Quad]</h4>
<p><strong></strong> A <span data-acronym-label="quad"
data-acronym-form="singular+short">quad</span> is a subdivision of four
<span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s in a <span
data-acronym-label="wave" data-acronym-form="singular+short">wave</span>
which are computing adjacent values. In pixel shaders a <span
data-acronym-label="quad" data-acronym-form="singular+short">quad</span>
may represent four adjacent pixels and <span data-acronym-label="quad"
data-acronym-form="singular+short">quad</span> operations allow passing
data between adjacent <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s. In compute shaders
quads may be one or two dimensional depending on the workload
dimensionality. Quad operations require four active <span
data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s.</p>
<h4 id="Intro.Model.Terms.Group"><span data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>[Intro.Model.Terms.Group]</h4>
<p><strong></strong> A grouping of <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s executing the same
shader to produce a combined result is called a <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>. <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>s are independent
of <span data-acronym-label="simd"
data-acronym-form="singular+abbrv">simd</span> hardware specifications.
The dimensions of a <span data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span> are defined in
three dimensions. The maximum extent along each dimension of a <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>, and the total
size of a <span data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span> are implementation
limits defined by the runtime and enforced by the compiler. If a <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>’s size is not a
whole multiple of the hardware <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span> size, the unused hardware
<span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s are implicitly
inactive.</p>
<p><strong></strong> If a <span data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span> size is smaller
than the <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span> size , or if the <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span> size is not an
even multiple of the <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span> size, the remaining <span
data-acronym-label="lane" data-acronym-form="singular+short">lane</span>
are <em>inactive</em> <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s.</p>
<h4 id="Intro.Model.Terms.Dispatch"><span data-acronym-label="dispatch"
data-acronym-form="singular+short">dispatch</span>[Intro.Model.Terms.Dispatch]</h4>
<p><strong></strong> A grouping of <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>s which represents
the full execution of a <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> program and results in a
completed result for all input data elements.</p>
<h4 id="Intro.Model.Terms.LaneState"><span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>
States[Intro.Model.Terms.LaneState]</h4>
<p><strong></strong> <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s may be in four primary
states: <em>active</em>, <em>helper</em>, <em>inactive</em>, and
<em>predicated off</em>.</p>
<p><strong></strong> An <em>active</em> <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span> is enabled to perform
computations and produce output results based on the initial launch
conditions and program control flow.</p>
<p><strong></strong> A <em>helper</em> <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span> is a lane which would not
be executed by the initial launch conditions except that its
computations are required for adjacent pixel operations in pixel
fragment shaders. A <em>helper</em> <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span> will execute all
computations but will not perform writes to buffers, and any outputs it
produces are discarded. <em>Helper</em> lanes may be required for <span
data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>-cooperative operations to
execute correctly.</p>
<p><strong></strong> A <em>inactive</em> <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span> is a lane that is not
executed by the initial launch conditions. This can occur if there are
insufficient inputs to fill all <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s in the <span
data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>, or to reduce per-thread
memory requirements or register pressure.</p>
<p><strong></strong> A <em>predicated off</em> <span
data-acronym-label="lane" data-acronym-form="singular+short">lane</span>
is a lane that is not being executed due to program control flow. A
<span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span> may be <em>predicated
off</em> when control flow for the <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s in a <span
data-acronym-label="wave" data-acronym-form="singular+short">wave</span>
diverge and one or more lanes are temporarily not executing.</p>
<p><strong></strong> The diagram blow illustrates the state transitions
between <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span> states:</p>
<h3 id="Intro.Model.Exec"><span data-acronym-label="spmd"
data-acronym-form="singular+abbrv">spmd</span> Execution
Model[Intro.Model.Exec]</h3>
<p><strong></strong> A runtime implementation shall provide an
implementation-defined mechanism for defining a <span
data-acronym-label="dispatch"
data-acronym-form="singular+short">dispatch</span>. A runtime shall
manage hardware resources and schedule execution to conform to the
behaviors defined in this specification in an implementation-defined
way. A runtime implementation may sort the <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>s of a <span
data-acronym-label="dispatch"
data-acronym-form="singular+short">dispatch</span> into <span
data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>s in an
implementation-defined way. During execution no guarantees are made that
all <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s in a <span
data-acronym-label="wave" data-acronym-form="singular+short">wave</span>
are actively executing.</p>
<p><strong></strong> <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>, <span
data-acronym-label="quad"
data-acronym-form="singular+short">quad</span>, and <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span> operations require
execution synchronization of applicable active and helper <span
data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s as defined by the
individual operation.</p>
<h3 id="Intro.Model.Restrictions">Optimization
Restrictions[Intro.Model.Restrictions]</h3>
<p><strong></strong> An optimizing compiler may not optimize code
generation such that it changes the behavior of a well-formed program
except in the presence of <em>implementation-defined</em> or
<em>unspecified</em> behavior.</p>
<p><strong></strong> The presence of <span data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>, <span
data-acronym-label="quad"
data-acronym-form="singular+short">quad</span>, or <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span> operations may
further limit the valid transformations of a program. Specifically,
control flow operations which result in changing which <span
data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s, <span
data-acronym-label="quad"
data-acronym-form="singular+short">quad</span>s, or <span
data-acronym-label="wave"
data-acronym-form="singular+short">wave</span>s are actively executing
are illegal in the presence of cooperative operations if the
optimization alters the behavior of the program.</p>
<h2 id="Intro.Memory"><span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> Memory
Models[Intro.Memory]</h2>
<p><strong></strong> Memory accesses for <span data-acronym-label="sm"
data-acronym-form="singular+short">sm</span> 5.0 and earlier operate on
128-bit slots aligned on 128-bit boundaries. This optimized for the
common case in early shaders where data being processed on the GPU was
usually 4-element vectors of 32-bit data types.</p>
<p><strong></strong> On modern hardware memory access restrictions are
loosened, and reads of 32-bit multiples are supported starting with
<span data-acronym-label="sm"
data-acronym-form="singular+short">sm</span> 5.1 and reads of 16-bit
multiples are supported with <span data-acronym-label="sm"
data-acronym-form="singular+short">sm</span> 6.0. <span
data-acronym-label="sm" data-acronym-form="singular+short">sm</span>
features are fully documented in the <span data-acronym-label="dx"
data-acronym-form="singular+short">dx</span> Specifications, and this
document will not attempt to elaborate further.</p>
<h3 id="Intro.Memory.Spaces">Memory Spaces[Intro.Memory.Spaces]</h3>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> programs manipulate data
stored in four distinct memory spaces: thread, threadgroup, device and
constant.</p>
<h4 id="Intro.Memory.Spaces.Thread">Thread
Memory[Intro.Memory.Spaces.Thread]</h4>
<p><strong></strong> Thread memory is local to the <span
data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>. It is the default memory
space used to store local variables. Thread memory cannot be directly
read from other threads without the use of intrinsics to synchronize
execution and memory.</p>
<h4 id="Intro.Memory.Spaces.Group"><span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>
Memory[Intro.Memory.Spaces.Group]</h4>
<p><strong></strong> <span data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span> memory is denoted
in <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> with the
<code>groupshared</code> keyword. The underlying memory for any
declaration annotated with <code>groupshared</code> is shared across an
entire <span data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>. Reads and writes
to <span data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span> Memory, may occur
in any order except as restricted by synchronization intrinsics or other
memory annotations.</p>
<h4 id="Intro.Memory.Spaces.Device">Device
Memory[Intro.Memory.Spaces.Device]</h4>
<p><strong></strong> Device memory is memory available to all <span
data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s executing on the device.
This memory may be read or written to by multiple <span
data-acronym-label="threadgroup"
data-acronym-form="singular+short">threadgroup</span>s that are
executing concurrently. Reads and writes to device memory may occur in
any order except as restricted by synchronization intrinsics or other
memory annotations. Some device memory may be visible to the host.
Device memory that is visible to the host may have additional
synchronization concerns for host visibility.</p>
<h4 id="Intro.Memory.Spaces.Constant">Constant
Memory[Intro.Memory.Spaces.Constant]</h4>
<p><strong></strong> Constant memory is similar to device memory in that
it is available to all <span data-acronym-label="lane"
data-acronym-form="singular+short">lane</span>s executing on the device.
Constant memory is read-only, and an implementation can assume that
constant memory is immutable and cannot change during execution.</p>
<h3 id="Intro.Memory.Alignment">Memory
Spaces[Intro.Memory.Alignment]</h3>
<p>TODO</p>
<p><strong></strong> The alignment requirements of an offset into device
memory space is the size in bytes of the largest scalar type contained
in the given aggregate type.</p>
<h1 id="Lex">Lexical Conventions[Lex]</h1>
<h2 id="Lex.Translation">Unit of Translation[Lex.Translation]</h2>
<p><strong></strong> The text of <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> programs is collected in
<em>source</em> and <em>header</em> files. The distinction between
source and header files is social and not technical. An implementation
will construct a <em>translation unit</em> from a single source file and
any included source or header files referenced via the
<code>#include</code> preprocessing directive conforming to the <span
data-acronym-label="isoC" data-acronym-form="singular+short">isoC</span>
preprocessor specification.</p>
<p><strong></strong> An implementation may implicitly include additional
sources as required to expose the <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> library functionality as
defined in (<a href="#Runtime" data-reference-type="ref"
data-reference="Runtime">13</a>).</p>
<h2 id="Lex.Phases">Phases of Translation[Lex.Phases]</h2>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> inherits the phases of
translation from <span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span>, with minor
alterations, specifically the removal of support for trigraph and
digraph sequences. Below is a description of the phases.</p>
<ol>
<li><p>Source files are characters that are mapped to the basic source
character set in an implementation-defined manner.</p></li>
<li><p>Any sequence of backslash (<code>\</code>) immediately followed
by a new line is deleted, resulting in splicing lines together.</p></li>
<li><p>Tokenization occurs and comments are isolated. If a source file
ends in a partial comment or preprocessor token the program is
ill-formed and a diagnostic shall be issued. Each comment block shall be
treated as a single white-space character.</p></li>
<li><p>Preprocessing directives are executed, macros are expanded,
<code>pragma</code> and other unary operator expressions are executed.
Processing of <code>#include</code> directives results in all preceding
steps being executed on the resolved file, and can continue recursively.
Finally all preprocessing directives are removed from the
source.</p></li>
<li><p>Character and string literal specifiers are converted into the
appropriate character set for the execution environment.</p></li>
<li><p>Adjacent string literal tokens are concatenated.</p></li>
<li><p>White-space is no longer significant. Syntactic and semantic
analysis occurs translating the whole translation unit into an
implementation-defined representation.</p></li>
<li><p>The translation unit is processed to determine required
instantiations, the definitions of the required instantiations are
located, and the translation and instantiation units are merged. The
program is ill-formed if any required instantiation cannot be located or
fails during instantiation.</p></li>
<li><p>External references are resolved, library references linked, and
all translation output is collected into a single output.</p></li>
</ol>
<h2 id="Lex.CharSet">Character Sets[Lex.CharSet]</h2>
<p><strong></strong> The <em>basic source character set</em> is a subset
of the ASCII character set. The table below lists the valid characters
and their ASCII values:</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Hex ASCII Value</th>
<th style="text-align: center;">Character Name</th>
<th style="text-align: center;">Glyph or C Escape Sequence</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0x09</td>
<td style="text-align: center;">Horizontal Tab</td>
<td style="text-align: center;"><code>\t</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x0A</td>
<td style="text-align: center;">Line Feed</td>
<td style="text-align: center;"><code>\n</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x0D</td>
<td style="text-align: center;">Carriage Return</td>
<td style="text-align: center;"><code>\r</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x20</td>
<td style="text-align: center;">Space</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x21</td>
<td style="text-align: center;">Exclamation Mark</td>
<td style="text-align: center;"><code>!</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x22</td>
<td style="text-align: center;">Quotation Mark</td>
<td style="text-align: center;"><code>"</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x23</td>
<td style="text-align: center;">Number Sign</td>
<td style="text-align: center;"><code>#</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x25</td>
<td style="text-align: center;">Percent Sign</td>
<td style="text-align: center;"><code>%</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x26</td>
<td style="text-align: center;">Ampersand</td>
<td style="text-align: center;"><code>&amp;</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x27</td>
<td style="text-align: center;">Apostrophe</td>
<td style="text-align: center;"><code>’</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x28</td>
<td style="text-align: center;">Left Parenthesis</td>
<td style="text-align: center;"><code>(</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x29</td>
<td style="text-align: center;">Right Parenthesis</td>
<td style="text-align: center;"><code>)</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x2A</td>
<td style="text-align: center;">Asterisk</td>
<td style="text-align: center;"><code>*</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x2B</td>
<td style="text-align: center;">Plus Sign</td>
<td style="text-align: center;"><code>+</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x2C</td>
<td style="text-align: center;">Comma</td>
<td style="text-align: center;"><code>,</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x2D</td>
<td style="text-align: center;">Hyphen-Minus</td>
<td style="text-align: center;"><code>-</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x2E</td>
<td style="text-align: center;">Full Stop</td>
<td style="text-align: center;"><code>.</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x2F</td>
<td style="text-align: center;">Solidus</td>
<td style="text-align: center;"><code>/</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x30 .. 0x39</td>
<td style="text-align: center;">Digit Zero .. Nine</td>
<td style="text-align: center;"><code>0 1 2 3 4 5 6 7 8 9</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x3A</td>
<td style="text-align: center;">Colon</td>
<td style="text-align: center;"><code>:</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x3B</td>
<td style="text-align: center;">Semicolon</td>
<td style="text-align: center;"><code>;</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x3C</td>
<td style="text-align: center;">Less-than Sign</td>
<td style="text-align: center;"><code>&lt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x3D</td>
<td style="text-align: center;">Equals Sign</td>
<td style="text-align: center;"><code>=</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x3E</td>
<td style="text-align: center;">Greater-than Sign</td>
<td style="text-align: center;"><code>&gt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x3F</td>
<td style="text-align: center;">Question Mark</td>
<td style="text-align: center;"><code>?</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x41 .. 0x5A</td>
<td style="text-align: center;">Latin Capital Letter A .. Z</td>
<td
style="text-align: center;"><code>A B C D E F G H I J K L M</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td
style="text-align: center;"><code>N O P Q R S T U V W X Y Z</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x5B</td>
<td style="text-align: center;">Left Square Bracket</td>
<td style="text-align: center;"><code>[</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x5C</td>
<td style="text-align: center;">Reverse Solidus</td>
<td style="text-align: center;"><code>\</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x5D</td>
<td style="text-align: center;">Right Square Bracket</td>
<td style="text-align: center;"><code>[</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x5E</td>
<td style="text-align: center;">Circumflex Accent</td>
<td style="text-align: center;"><code>^</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x5F</td>
<td style="text-align: center;">Underscore</td>
<td style="text-align: center;"><code>_</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x61 .. 0x7A</td>
<td style="text-align: center;">Latin Small Letter a .. z</td>
<td
style="text-align: center;"><code>a b c d e f g h i j k l m</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td
style="text-align: center;"><code>n o p q r s t u v w x y z</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x7B</td>
<td style="text-align: center;">Left Curly Bracket</td>
<td style="text-align: center;"><code>{</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">0x7C</td>
<td style="text-align: center;">Vertical Line</td>
<td style="text-align: center;"><code>|</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0x7D</td>
<td style="text-align: center;">Right Curly Bracket</td>
<td style="text-align: center;"><code>}</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong></strong> An implementation may allow source files to be
written in alternate <em>extended character sets</em> as long as that
set is a superset of the <em>basic character set</em>. The
<em>translation character set</em> is an <em>extended character set</em>
or the <em>basic character set</em> as chosen by the implementation.</p>
<h2 id="Lex.PPTokens">Preprocessing Tokens[Lex.PPTokens]</h2>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>preprocessing-token</em><span
class="nodecor">:</span></span><br />
* header-name<br />
* identifier<br />
* pp-number<br />
* character-literal<br />
* string-literal<br />
* preprocessing-op-or-punc<br />
* <span class="nodecor">each non-whitespace character from the
<em>translation character set</em> that cannot be one of the
above</span></p>
</div>
<p><a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p><strong></strong> Each preprocessing token that is converted to a
token shall have the lexical form of a keyword, an identifier, a
constant, a string literal or an operator or punctuator.</p>
<p><strong></strong> Preprocessing tokens are the minimal lexical
elements of the language during translation phases 3 through 6 (<a
href="#Lex.Phases" data-reference-type="ref"
data-reference="Lex.Phases">2.2</a>). Preprocessing tokens can be
separated by whitespace in the form of comments, white space characters,
or both. White space may appear within a preprocessing token only as
part of a header name or between the quotation characters in a character
constant or string literal.</p>
<p><strong></strong> Header name preprocessing tokens are only
recognized within <span>#include</span> preprocessing directives,
<span>__has_include</span> expressions, and implementation-defined
locations within <span>#pragma</span> directives. In those contexts, a
sequence of characters that could be either a header name or a string
literal is recognized as a header name.</p>
<h2 id="Lex.Tokens">Tokens[Lex.Tokens]</h2>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>token</em><span class="nodecor">:</span></span><br />
* identifier<br />
* keyword<br />
* literal<br />
* operator-or-punctuator</p>
</div>
<p><strong></strong> There are five kinds of tokens: identifiers,
keywords, literals, and operators or punctuators. All whitespace
characters and comments are ignored except as they separate tokens.</p>
<h2 id="Lex.Comments">Comments[Lex.Comments]</h2>
<p><strong></strong> The characters <span>/*</span> start a comment
which terminates with the characters <span>/</span>. The characters
<span>//</span> start a comment which terminates at the next new
line.</p>
<h2 id="Lex.Headers">Header Names[Lex.Headers]</h2>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>header-name</em><span class="nodecor">:</span></span><br />
* <span>&lt;</span> h-char-sequence <span>&gt;</span><br />
* <span>"</span> q-char-sequence <span>"</span></p>
<p><span><em>h-char-sequence</em><span
class="nodecor">:</span></span><br />
* h-char<br />
* h-char-sequence h-char</p>
<p><span><em>h-char</em><span class="nodecor">:</span></span><br />
* <span class="nodecor">any character in the <em>translation character
set</em> except newline or <span>&gt;</span></span></p>
<p><span><em>q-char-sequence</em><span
class="nodecor">:</span></span><br />
* q-char<br />
* q-char-sequence q-char</p>
<p><span><em>q-char</em><span class="nodecor">:</span></span><br />
* <span class="nodecor">any character in the <em>translation character
set</em> except newline or <span>"</span></span></p>
</div>
<p><strong></strong> Character sequences in header names are mapped to
header files or external source file names in an implementation defined
way.</p>
<h2 id="Lex.PPNumber">Preprocessing numbers[Lex.PPNumber]</h2>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>pp-number</em><span class="nodecor">:</span></span><br />
* digit<br />
* <span>.</span> digit<br />
* pp-number <span>’</span> digit<br />
* pp-number <span>’</span> non-digit<br />
* pp-number <span>e</span> sign<br />
* pp-number <span>E</span> sign<br />
* pp-number <span>p</span> sign<br />
* pp-number <span>P</span> sign<br />
* pp-number <span>.</span></p>
</div>
<p><strong></strong> Preprocessing numbers begin with a digit or period
(<span>.</span>), and may be followed by valid identifier characters and
floating point literal suffixes (<span>e+</span>, <span>e-</span>,
<span>E+</span>, <span>E-</span>, <span>p+</span>, <span>p-</span>,
<span>P+</span>, and <span>P-</span>). Preprocessing number tokens
lexically include all <em>integer-literal</em> and
<em>floating-literal</em> tokens.</p>
<p><strong></strong> Preprocessing numbers do not have types or values.
Types and values are assigned to <em>integer-literal</em>,
<em>floating-literal</em>, and <em>vector-literal</em> tokens on
successful conversion from preprocessing numbers.</p>
<p><strong></strong> A preprocessing number cannot end in a period
(<span>.</span>) if the immediate next token is a
<em>scalar-element-sequence</em> (<a href="#Lex.Literal.Vector"
data-reference-type="ref"
data-reference="Lex.Literal.Vector">2.9.4</a>). In this situation the
<em>pp-number</em> token is truncated to end before the period<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<h2 id="Lex.Literals">Literals[Lex.Literals]</h2>
<h3 id="Lex.Literal.Kinds">Literal
Classifications[Lex.Literal.Kinds]</h3>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>literal</em><span class="nodecor">:</span></span><br />
* integer-literal<br />
* character-literal<br />
* floating-literal<br />
* string-literal<br />
* boolean-literal<br />
* vector-literal</p>
</div>
<h3 id="Lex.Literal.Int">Integer Literals[Lex.Literal.Int]</h3>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>integer-literal</em><span
class="nodecor">:</span></span><br />
* decimal-literal
<span>integer-suffix<sub><em>opt</em></sub></span><br />
* octal-literal <span>integer-suffix<sub><em>opt</em></sub></span><br />
* hexadecimal-literal
<span>integer-suffix<sub><em>opt</em></sub></span><br />
*</p>
<p><span><em>decimal-literal</em><span
class="nodecor">:</span></span><br />
* nonzero-digit<br />
* decimal-literal digit<br />
*</p>
<p><span><em>octal-literal</em><span
class="nodecor">:</span></span><br />
* octal-literal octal-digit<br />
*</p>
<p><span><em>hexadecimal-literal</em><span
class="nodecor">:</span></span><br />
* <span>0x</span> hexadecimal-digit<br />
* <span>0X</span> hexadecimal-digit<br />
* hexadecimal-literal hexadecimal-digit<br />
*</p>
<p><span><em>nonzero-digit</em><span class="nodecor">:</span></span>
<span class="nodecor">one of</span><br />
* <span> 2 3 4 5 6 7 8 9</span><br />
*</p>
<p><span><em>octal-digit</em><span class="nodecor">:</span></span> <span
class="nodecor">one of</span><br />
* <span> 1 2 3 4 5 6 7</span><br />
*</p>
<p><span><em>hexadecimal-digit</em><span class="nodecor">:</span></span>
<span class="nodecor">one of</span><br />
* <span> 1 2 3 4 5 6 7 8 9</span><br />
* <span>a b c d e f</span><br />
* <span>A B C D E F</span><br />
*</p>
<p><span><em>integer-suffix</em><span
class="nodecor">:</span></span><br />
* unsigned-suffix <span>long-suffix<sub><em>opt</em></sub></span><br />
* long-suffix <span>unsigned-suffix<sub><em>opt</em></sub></span><br />
*</p>
<p><span><em>unsigned-suffix</em><span class="nodecor">:</span></span>
<span class="nodecor">one of</span><br />
* <span>u U</span><br />
*</p>
<p><span><em>long-suffix</em><span class="nodecor">:</span></span> <span
class="nodecor">one of</span><br />
* <span>l L</span></p>
</div>
<p><strong></strong> An <em>integer literal</em> is an optional base
prefix, a sequence of digits in the appropriate base, and an optional
type suffix. An integer literal shall not contain a period or exponent
specifier.</p>
<p><strong></strong> The type of an integer literal is the first of the
corresponding list in the table below in which its value can be
represented<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Suffix</th>
<th style="text-align: center;">Decimal constant</th>
<th style="text-align: center;">Octal or hexadecimal constant</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">none</td>
<td style="text-align: center;"><span>int32_t</span></td>
<td style="text-align: center;"><span>int32_t</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span>int64_t</span></td>
<td style="text-align: center;"><span>uint32_t</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span>int64_t</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span>uint64_t</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span>u</span> or <span>U</span></td>
<td style="text-align: center;"><span>uint32_t</span></td>
<td style="text-align: center;"><span>uint32_t</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span>uint64_t</span></td>
<td style="text-align: center;"><span>uint64_t</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span>l</span> or <span>L</span></td>
<td style="text-align: center;"><span>int64_t</span></td>
<td style="text-align: center;"><span>int64_t</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span>uint64_t</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Both <span>u</span> or
<span>U</span></td>
<td style="text-align: center;"><span>uint64_t</span></td>
<td style="text-align: center;"><span>uint64_t</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">and <span>l</span> or
<span>L</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><strong></strong> If the specified value of an integer literal cannot
be represented by any type in the corresponding list, the integer
literal has no type and the program is ill-formed.</p>
<p><strong></strong> An implementation may support the integer suffixes
<span>ll</span> and <span>ull</span> as equivalent to <span>l</span> and
<span>ul</span> respectively.</p>
<h3 id="Lex.Literal.Float">Floating-point
Literals[Lex.Literal.Float]</h3>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>floating-literal</em><span
class="nodecor">:</span></span><br />
* fractional-constant <span>exponent-part<sub><em>opt</em></sub></span>
<span>floating-suffix<sub><em>opt</em></sub></span><br />
* digit-sequence exponent-part
<span>floating-suffx<sub><em>opt</em></sub></span><br />
* <span><em>fractional-constant</em><span
class="nodecor">:</span></span><br />
* <span>digit-sequence<sub><em>opt</em></sub></span> <span>.</span>
digit-sequence<br />
* digit-sequence <span>.</span><br />
* <span><em>exponent-part</em><span
class="nodecor">:</span></span><br />
* <span>e</span> <span>sign<sub><em>opt</em></sub></span>
digit-sequence<br />
* <span>E</span> <span>sign<sub><em>opt</em></sub></span>
digit-sequence<br />
* <span><em>sign</em><span class="nodecor">:</span></span> <span
class="nodecor">one of</span><br />
* <span>+</span> <span>-</span><br />
* <span><em>digit-sequence</em><span
class="nodecor">:</span></span><br />
* digit<br />
* digit-sequence digit <span><em>floating-suffix</em><span
class="nodecor">:</span></span> <span class="nodecor">one of</span>
<span>h</span> <span>f</span> <span>l</span> <span>H</span>
<span>F</span> <span>L</span></p>
</div>
<p><strong></strong> A floating literal is written either as a
<em>fractional-constant</em> with an optional <em>exponent-part</em> and
optional <em>floating-suffix</em>, or as an integer
<em>digit-sequence</em> with a required <em>exponent-part</em> and
optional <em>floating-suffix</em>.</p>
<p><strong></strong> The type of a floating literal is
<span>float</span>, unless explicitly specified by a suffix. The
suffixes <span>h</span> and <span>H</span> specify <span>half</span>,
the suffixes <span>f</span> and <span>F</span> specify
<span>float</span>, and the suffixes <span>l</span> and <span>L</span>
specify <span>double</span>.<a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a> If a value specified in
the source is not in the range of representable values for its type, the
program is ill-formed.</p>
<h3 id="Lex.Literal.Vector">Vector Literals[Lex.Literal.Vector]</h3>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>vector-literal</em><span
class="nodecor">:</span></span><br />
* integer-literal <span>.</span> scalar-element-sequence<br />
* floating-literal <span>.</span> scalar-element-sequence</p>
<p><span><em>scalar-element-sequence</em><span
class="nodecor">:</span></span><br />
* scalar-element-sequence-x<br />
* scalar-element-sequence-r</p>
<p><span><em>scalar-element-sequence-x</em><span
class="nodecor">:</span></span><br />
* <span>x</span><br />
* scalar-element-sequence-x <span>x</span></p>
<p><span><em>scalar-element-sequence-r</em><span
class="nodecor">:</span></span><br />
* <span>r</span><br />
* scalar-element-sequence-r <span>r</span></p>
</div>
<p><strong></strong> A <em>vector-literal</em> is an
<em>integer-literal</em> or <em>floating-point</em> literal followed by
a period (<span>.</span>) and a <em>scalar-element-sequence</em>.</p>
<p><strong></strong> A <em>scalar-element-sequence</em> is a
<em>vector-swizzle-sequence</em> where only the first vector element
accessor is valid (<span>x</span> or <span>r</span>). A
<em>scalar-element-sequence</em> is equivalent to a vector splat
conversion performed on the <em>integer-literal</em> or
<em>floating-literal</em> value (<a href="#Conv.vsplat"
data-reference-type="ref" data-reference="Conv.vsplat">4.10</a>).</p>
<h1 id="Basic">Basic Concepts[Basic]</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong></strong> HLSL inherits a
significant portion of its language semantics from C and C++. Some of
this is a result of intentional adoption of syntax early in the
development of the language and some a side-effect of the Clang-based
implementation of DXC.</p>
<p><strong></strong> This chapter includes a lot of definitions that are
inherited from C and C++. Some are identical to C or C++, others are
slightly different. HLSL is neither a subset nor a superset of C or C++,
and cannot be simply described in terms of C or C++. This specification
includes all necessary definitions for clarity.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Basic.preamble">Preamble[Basic.preamble]</h2>
<p><strong></strong> An <em>entity</em> is a value, object, function,
enumerator, type, class member, bit-field, template, template
specialization, namespace, or pack.</p>
<p><strong></strong> A <em>name</em> is a use of an <em>identifier</em>
(<a href="#Expr.Primary.ID" data-reference-type="ref"
data-reference="Expr.Primary.ID">5.2.4</a>),
<em>operator-function-id</em> (<a href="#Overload.operator"
data-reference-type="ref"
data-reference="Overload.operator">[Overload.operator]</a>),
<em>conversion-function-id</em> (<a href="#Classes.Conversions"
data-reference-type="ref"
data-reference="Classes.Conversions">10.2</a>), or <em>template-id</em>
(<a href="#Template" data-reference-type="ref"
data-reference="Template">11</a>) that denotes any entity or
<em>label</em> (<a href="#Stmt.Label" data-reference-type="ref"
data-reference="Stmt.Label">6.1</a>).</p>
<p><strong></strong> Every name that denotes an entity is introduced by
a <em>declaration</em>. Every name that denotes a label is introduced by
a <em>labeled statement</em> (<a href="#Stmt.Label"
data-reference-type="ref" data-reference="Stmt.Label">6.1</a>)<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>.</p>
<p><strong></strong> A <em>variable</em> is introduced by the
declaration of a reference other than a non-static data member of an
object. The variable’s name denotes the reference or object.</p>
<p><strong></strong> Whenever a name is encountered it is necessary to
determine if the name denotes an entity that is a type or template. The
process for determining if a name refers to a type or template is called
<em>name lookup</em>.</p>
<p><strong></strong> Two names are the same name if:</p>
<ul>
<li><p>they are identifiers comprised of the same character sequence,
or</p></li>
<li><p>they are operator-function-ids formed with the same operator,
or</p></li>
<li><p>they are conversion-function-ids formed with the same type,
or</p></li>
<li><p>they are template-ids that refer to the same class or
function.</p></li>
</ul>
<p><strong></strong></p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">This section matches <span
data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span> section
<strong>[basic]</strong> except for the exclusion of <span>goto</span>
and <em>literal operators</em>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Basic.Decl">Declarations and definitions[Basic.Decl]</h2>
<p><strong></strong> A declaration (<a href="#Decl"
data-reference-type="ref" data-reference="Decl">7</a>) may introduce one
or more names into a translation unit or redeclare names introduced by
previous declarations. If a declaration introduces names, it specifies
the interpretation and attributes of these names. A declaration may also
have effects such as:</p>
<ul>
<li><p>verifying a static assertion (<a href="#Decl"
data-reference-type="ref" data-reference="Decl">7</a>),</p></li>
<li><p>use of attributes (<a href="#Decl" data-reference-type="ref"
data-reference="Decl">7</a>), and</p></li>
<li><p>controlling template instantiation (<a href="#Template.Inst"
data-reference-type="ref"
data-reference="Template.Inst">11.1</a>).</p></li>
</ul>
<p><strong></strong> A declaration is a <em>definition</em> unless:</p>
<ul>
<li><p>it declares a function without specifying the function’s body (<a
href="#Decl.Function" data-reference-type="ref"
data-reference="Decl.Function">7.5</a>),</p></li>
<li><p>it is a parameter declaration in a function declaration that does
not specify the function’s body (<a href="#Decl.Function"
data-reference-type="ref"
data-reference="Decl.Function">7.5</a>),</p></li>
<li><p>it is a global or namespace member declaration without the
<span>static</span> specifier<a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a>,</p></li>
<li><p>it declares a static data member in a class definition,</p></li>
<li><p>it is a class name declaration,</p></li>
<li><p>it is a template parameter,</p></li>
<li><p>it is a <span>typedef</span> declaration (<a href="#Decl"
data-reference-type="ref" data-reference="Decl">7</a>),</p></li>
<li><p>it is an <em>alias-declaration</em> (<a href="#Decl"
data-reference-type="ref" data-reference="Decl">7</a>),</p></li>
<li><p>it is a <em>using-declaration</em> (<a href="#Decl"
data-reference-type="ref" data-reference="Decl">7</a>),</p></li>
<li><p>it is a <em>static_assert-declaration</em> (<a href="#Decl"
data-reference-type="ref" data-reference="Decl">7</a>),</p></li>
<li><p>it is an <em>empty-declaration</em> (<a href="#Decl"
data-reference-type="ref" data-reference="Decl">7</a>),</p></li>
<li><p>or a <em>using-directive</em> (<a href="#Decl"
data-reference-type="ref" data-reference="Decl">7</a>).</p></li>
</ul>
<p><strong></strong> The two examples below are adapted from <span
data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span>
<strong>[basic.def]</strong>. All but one of the following are
definitions:</p>
<div class="HLSL">
<p>int f(int x) <span> return x+1; </span> // defines f and x struct S
<span>int a;int b;</span>; // defines S, S::a, and S::b struct X <span>
// defines X int x; // defines non-static member x static int y; //
declares static data member y </span>; int X::y = 1; // defines X::y
enum <span> up, down </span>; // defines up and down namespace N <span>
// defines N int d; // declares N::d static int i; // defines N::i
</span></p>
</div>
<p><strong></strong> All of the following are declarations:</p>
<div class="HLSL">
<p>int a; // declares a const int c; // declares c X anX; // declares
anX int f(int); // declares f struct S; // declares S typedef int Int;
// declares Int using N::d; // declares d using Float = float; //
declares Float cbuffer CB <span> // does not declare CB int z; //
declares z </span> tbuffer TB <span> // does not declare TB int w; //
declares w </span></p>
</div>
<h2 id="Basic.ODR">One-Definition Rule[Basic.ODR]</h2>
<p><strong></strong> The <span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span> <em>One-definition
rule</em> is adopted as defined in <span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span>
<strong>[basic.def.odr]</strong>.</p>
<h2 id="Basic.Scope">Scope[Basic.Scope]</h2>
<h2 id="Basic.Lookup">Name Lookup[Basic.Lookup]</h2>
<h2 id="Basic.Linkage">Program and linkage[Basic.Linkage]</h2>
<p><strong></strong> A translation unit (<a href="#Lex.Translation"
data-reference-type="ref" data-reference="Lex.Translation">2.1</a>) is
comprised of a sequence of declarations:</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>translation-unit</em><span
class="nodecor">:</span></span><br />
* <span>declaration-sequence<sub><em>opt</em></sub></span></p>
</div>
<p><strong></strong> A <em>program</em> is one or more translation units
<em>linked</em> together. A program built from a single translation
unit, bypassing a linking step is called <em>freestanding</em>.</p>
<p><strong></strong> A program is said to be <em>fully linked</em>, when
it contains no <em>unresolved external</em> declarations, and all
<em>exported</em> declarations are entry point declarations (<a
href="#Basic.Start" data-reference-type="ref"
data-reference="Basic.Start">3.7</a>). A program is said to be
<em>partially linked</em>, when it contains at least one unresolved
external declaration or at least one exported declaration that is not an
entry point.</p>
<p><strong></strong> An implementation may generate programs as fully
linked or partially linked as requested by the user, and a runtime may
allow fully linked or partially linked programs as the implementation
allows.</p>
<p><strong></strong> A name has <em>linkage</em> if it can refer to the
same entity as a name introduced by a declaration in another scope. If a
variable, function, or another entity with the same name is declared in
several scopes, but does not have sufficient <em>linkage</em>, then
several instances of the entity are generated.</p>
<ul>
<li><p>A name with <em>no linkage</em> may not be referred to by names
from any other scope.</p></li>
<li><p>A name with <em>internal linkage</em> may be referred to by names
from other scopes within the same translation unit.</p></li>
<li><p>A name with <em>external linkage</em> may be referred to by names
from other scopes within the same translation unit, and by names from
scopes of other translation units.</p></li>
<li><p>A name with <em>program linkage</em> may be referred to by names
from other scopes within the same translation unit, by names from scopes
of other translation units, by names from scopes of other programs, and
by a runtime implementation.</p></li>
</ul>
<p><strong></strong> When merging translation units through linking or
generating a freestanding program only names with program linkage must
be retained in the final program.</p>
<h3 id="Basic.Linkage.Program">Program
Linkage[Basic.Linkage.Program]</h3>
<p><strong></strong> Entities with <em>program linkage</em> can be
referred to from other partially linked programs or a runtime
implementation.</p>
<p><strong></strong> The following entities have program linkage:</p>
<ul>
<li><p>entry point functions (<a href="#Basic.Start"
data-reference-type="ref" data-reference="Basic.Start">3.7</a>)</p></li>
<li><p>functions marked with <span>export</span> keyword (<a
href="#Decl.Export" data-reference-type="ref"
data-reference="Decl.Export">7.7</a>)</p></li>
<li><p>declarations contained within an
<em>export-declaration-group</em> (<a href="#Decl.Export"
data-reference-type="ref" data-reference="Decl.Export">7.7</a>)</p></li>
</ul>
<h3 id="Basic.Linkage.External">External
Linkage[Basic.Linkage.External]</h3>
<p><strong></strong> Entities with <em>external linkage</em> can be
referred to from the scopes in the other translation units and enable
linking between them.</p>
<p><strong></strong> The following entities in HLSL have <em>external
linkage</em>:</p>
<ul>
<li><p>global variables that are not marked <span>static</span> or
<span>groupshared</span> <a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a></p></li>
<li><p>static data members of classes or template classes</p></li>
</ul>
<p><strong></strong> Linkage of functions (including template functions)
that are not entry points or marked with <span>export</span> keyword is
implementation dependent. <a href="#fn8" class="footnote-ref"
id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<h3 id="Basic.Linkage.Internal">Internal
Linkage[Basic.Linkage.Internal]</h3>
<p><strong></strong> Entities with <em>internal linkage</em> can be
referred to from all scopes in the current translation unit.</p>
<p><strong></strong> The following entities in HLSL have <em>internal
linkage</em>:</p>
<ul>
<li><p>global variables marked as <span>static</span> or
<span>groupshared</span></p></li>
<li><p>all entities declared in an unnamed namespace or a namespace
within an unnamed namespace</p></li>
<li><p>enumerations</p></li>
<li><p>classes or template classes, their member functions, and nested
classes and enumerations</p></li>
</ul>
<h3 id="Basic.Linkage.NoLinkage">No
Linkage[Basic.Linkage.NoLinkage]</h3>
<p><strong></strong> An entity with <em>no linkage</em> can be referred
to only from the scope it is in.</p>
<p><strong></strong> Any of the following entites declared at function
scope or block scopes derived from function scope have no linkage:</p>
<ul>
<li><p>local variables</p></li>
<li><p>local classes and their member functions</p></li>
<li><p>other entities declared at function scope or block scopes derived
from function scope that such as typedefs, enumerations, and
enumerators</p></li>
</ul>
<h2 id="Basic.Start">Start[Basic.Start]</h2>
<p><strong></strong> A fully linked program shall contain one or more
global functions, which are the designated starting points for the
program. These global functions are called <em>entry points</em>,
because they denote the location where execution inside the program
begins.</p>
<p><strong></strong> Entry point functions have different requirements
based on the target runtime and execution mode (<a
href="#Basic.Start.Mode" data-reference-type="ref"
data-reference="Basic.Start.Mode">3.7.1</a>).</p>
<p><strong></strong> Parameters to entry functions and entry function
return types must be of scalar, vector, or non-intangible class type (<a
href="#Basic.types" data-reference-type="ref"
data-reference="Basic.types">3.8</a>). Scalar and vector parameters and
return types must be annotated with semantic annotations (<a
href="#Decl.Attr.Semantic" data-reference-type="ref"
data-reference="Decl.Attr.Semantic">7.6.1</a>). Class type input and
output parameters must have all fields annotated with semantic
annotations.</p>
<h3 id="Basic.Start.Mode">Execution Mode[Basic.Start.Mode]</h3>
<p><strong></strong> A runtime may define a set of execution modes in an
implementation defined way. Each execution mode will have a set of
implementation defined rules which restrict available language
functionality as appropriate for the execution mode.</p>
<h2 id="Basic.types">Types[Basic.types]</h2>
<p><strong></strong> The <em>object representation</em> of an object of
type <span>T</span> is the sequence of <em>N</em> bytes taken up by the
object of type <span>T</span>, where <em>N</em> equals
<span>sizeof(T)</span><a href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>. The <em>object representation</em>
of an object may be different based on the <em>memory space</em> it is
stored in (<a href="#Intro.Memory.Spaces" data-reference-type="ref"
data-reference="Intro.Memory.Spaces">1.7.1</a>).</p>
<p><strong></strong> The <em>value representation</em> of an object is
the set of bits that hold the value of type <span>T</span>. Bits in the
object representation that are not part of the value representation are
<em>padding bits</em>.</p>
<p><strong></strong> An <em>object type</em> is a type that is not a
function type, not a reference type, and not a void type.</p>
<p><strong></strong> A <em>class type</em> is a data type declared with
either the <span>class</span> or <span>struct</span> keywords (<a
href="#Classes" data-reference-type="ref"
data-reference="Classes">10</a>). A class type <span>T</span> may be
declared as incomplete at one point in a translation unit via a
<em>forward declaration</em>, and complete later with a full definition.
The type <span>T</span> is the same type throughout the translation
unit.</p>
<p><strong></strong> There are special implementation-defined types such
as <em>handle types</em>, which fall into a category of <em>standard
intangible types</em>. Intangible types are types that have no defined
object representation or value representation, as such the size is
unknown at compile time. Usage restrictions for objects of intangible
type are documented in <a href="#Basic.types.intangible"
data-reference-type="ref"
data-reference="Basic.types.intangible">3.8.3</a>.</p>
<p><strong></strong> A class type <span>T</span> is an <em>intangible
class type</em> if it contains a base class or members of intangible
class type, standard intangible type, or arrays of such types. Standard
intangible types and intangible class types are collectively called
<em>intangible types</em>(<a href="#Intangible"
data-reference-type="ref" data-reference="Intangible">12</a>).</p>
<p><strong></strong> An object type is an <em>incomplete type</em> if
the compiler lacks sufficient information to determine the size of an
object of type <span>T</span>, and it is not an intangible type. It is a
<em>complete type</em> if the compiler has sufficient information to
determine the size of an object of type <span>T</span>, or if the type
is known to be an intangible type. An object may not be defined to have
an <em>incomplete</em> type.</p>
<p><strong></strong> Arithmetic types (<a href="#Basic.types.arithmetic"
data-reference-type="ref"
data-reference="Basic.types.arithmetic">3.8.1</a>), enumeration types,
and <em>cv-qualified</em> versions of these types are collectively
called <em>scalar types</em>.</p>
<p><strong></strong> Vectors of scalar types declared with the built-in
<span>vector&lt;T,N&gt;</span> template are <em>vector types</em>.
Vector lengths must be between 1 and 4 (i.e. <span
class="math inline">1 ≤ <em>N</em> ≤ 4</span> ).</p>
<p><strong></strong> Matrices of scalar types declared with the built-in
<span>matrix&lt;T,N,M&gt;</span> template are <em>matrix types</em>.
Matrix dimensions, <span>N</span> and <span>M</span>, must be between 1
and 4 (i.e. <span class="math inline">1 ≤ <em>N</em> ≤ 4</span> ).</p>
<h3 id="Basic.types.arithmetic">Arithmetic
Types[Basic.types.arithmetic]</h3>
<p><strong></strong> There are three <em>standard signed integer
types</em>: <span>int16_t</span>, <span>int32_t</span>, and
<span>int64_t</span>. Each of the signed integer types is explicitly
named for the size in bits of the type’s object representation. There is
also the type alias <span>int</span> which is an alias of
<span>int32_t</span>. There is one <em>minimum precision signed integer
type</em>: <span>min16int</span>. The minimum precision signed integer
type is named for the required minimum value representation size in
bits. The object representation of <span>min16int</span> is
<span>int</span>. The standard signed integer types and minimum
precision signed integer type are collectively called <em>signed integer
types</em>.</p>
<p><strong></strong> There are three <em>standard unsigned integer
types</em>: <span>uint16_t</span>, <span>uint32_t</span>, and
<span>uint64_t</span>. Each of the unsigned integer types is explicitly
named for the size in bits of the type’s object representation. There is
also the type alias <span>uint</span> which is an alias of
<span>uint32_t</span>. There is one <em>minimum precision unsigned
integer type</em>: <span>min16uint</span>. The minimum precision
unsigned integer type is named for the required minimum value
representation size in bits. The object representation of
<span>min16uint</span> is <span>uint</span>. The standard unsigned
integer types and minimum precision unsigned integer type are
collectively called <em>unsigned integer types</em>.</p>
<p><strong></strong> The minimum precision signed integer types and
minimum precision unsigned integer types are collectively called
<em>minimum precision integer types</em>. The standard signed integer
types and standard unsigned integer types are collectively called
<em>standard integer types</em>. The signed integer types and unsigned
integer types are collectively called <em>integer types</em>. Integer
types inherit the object representation of integers defined in <span
data-acronym-label="isoC23"
data-acronym-form="singular+long">isoC23</span><a href="#fn10"
class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>.
Integer types shall satisfy the constraints defined in <span
data-acronym-label="isoCPP"
data-acronym-form="singular+long">isoCPP</span>, section
<strong>basic.fundamental</strong>.</p>
<p><strong></strong> There are three <em>standard floating point
types</em>: <span>half</span>, <span>float</span>, and
<span>double</span>. The <span>float</span> type is a 32-bit floating
point type. The <span>double</span> type is a 64-bit floating point
type. Both the <span>float</span> and <span>double</span> types have
object representations as defined in <span data-acronym-label="IEEE754"
data-acronym-form="singular+short">IEEE754</span>. The <span>half</span>
type may be either 16-bit or 32-bit as controlled by implementation
defined compiler settings. If <span>half</span> is 32-bit it will have
an object representation as defined in <span
data-acronym-label="IEEE754"
data-acronym-form="singular+short">IEEE754</span>, otherwise it will
have an object representation matching the <strong>binary16</strong>
format defined in <span data-acronym-label="IEEE754"
data-acronym-form="singular+short">IEEE754</span><a href="#fn11"
class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>.
There is one <em>minimum precision floating point type</em>:
<span>min16float</span>. The minimum precision floating point type is
named for the required minimum value representation size in bits. The
object representation of <span>min16float</span> is <span>float</span><a
href="#fn12" class="footnote-ref" id="fnref12"
role="doc-noteref"><sup>12</sup></a>. The standard floating point types
and minimum precision floating point type are collectively called
<em>floating point types</em>.</p>
<p><strong></strong> Integer and floating point types are collectively
called <em>arithmetic types</em>.</p>
<p><strong></strong> The <span>void</span> type is inherited from <span
data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span>, which defines it as
having an empty set of values and being an incomplete type that can
never be completed. The <span>void</span> type is used to signify the
return type of a function that returns no value. Any expression can be
explicitly converted to <span>void</span>.</p>
<h3 id="Basic.types.scalarized">Scalarized Type
Compatability[Basic.types.scalarized]</h3>
<p><strong></strong> All types <span>T</span> have a <em>scalarized
representation</em>, <span
class="math inline"><em>S</em><em>R</em>(<em>T</em>)</span>, which is a
list of one or more types representing each scalar element of
<span>T</span>.</p>
<p><strong></strong> Scalarized representations are determined as
follows:</p>
<ul>
<li><p>The scalarized representation of an array <span>T[n]</span> is
<span
class="math inline"><em>S</em><em>R</em>(<em>T</em><sub>0</sub>), ..<em>S</em><em>R</em>(<em>T</em><sub><em>n</em></sub>)</span>.</p></li>
<li><p>The scalarized representation of a vector
<span>vector&lt;T,n&gt;</span> is <span
class="math inline"><em>T</em><sub>0</sub>, ..<em>T</em><sub><em>n</em></sub></span>.</p></li>
<li><p>The scalarized representation of a matrix <span>matrix&lt;T,n,
m&gt;</span> is <span
class="math inline"><em>T</em><sub>0</sub>, ..<em>T</em><sub><em>n</em> × <em>m</em></sub></span>.</p></li>
<li><p>The scalarized representation of a class type <span>T</span>,
<span class="math inline"><em>S</em><em>R</em>(<em>T</em>)</span> is
computed recursively as <span
class="math inline"><em>S</em><em>R</em>(<em>T</em>::<em>b</em><em>a</em><em>s</em><em>e</em>), <em>S</em><em>R</em>(<em>T</em>::<sub>0</sub>), ..<em>S</em><em>R</em>(<em>T</em>::<sub><em>n</em></sub>)</span>
where <span>(</span>T::base) is <span>T</span>’s base class if it has
one, and <span
class="math inline"><em>T</em> : :<sub><em>n</em></sub></span>
represents the <em>n</em> non-static members of <span>T</span>.</p></li>
<li><p>The scalarized representation for an enumeration type is the
underlying arithmetic type.</p></li>
<li><p>The scalarized representation for arithmetic, intangible types,
and any other type <span>T</span> is <span
class="math inline"><em>T</em></span>.</p></li>
</ul>
<p><strong></strong> Two types <em>cv1</em> <span>T1</span> and
<em>cv2</em> <span>T2</span> are <em>scalar-layout-compatible types</em>
if <span>T1</span> and <span>T2</span> are the same type or if the
sequence of types defined by the scalar representation <span
class="math inline"><em>S</em><em>R</em>(<em>T</em>1)</span> and scalar
representation <span
class="math inline"><em>S</em><em>R</em>(<em>T</em>2)</span> are
identical.</p>
<h3 id="Basic.types.intangible">Usage of Intangible
Types[Basic.types.intangible]</h3>
<p><strong></strong> The following usage restrictions apply to
intangible types:</p>
<ul>
<li><p>Instances of objects of intangible type may only be declared in
the Thread address space (<a href="#Intro.Memory.Spaces"
data-reference-type="ref"
data-reference="Intro.Memory.Spaces">1.7.1</a>).</p></li>
<li><p>An object of intangible type may not be loaded or stored to any
address space other than the Thread address space (<a
href="#Intro.Memory.Spaces" data-reference-type="ref"
data-reference="Intro.Memory.Spaces">1.7.1</a>).<a href="#fn13"
class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a></p></li>
<li><p>An object of intangible type may not be a parameter or return
type of a function with program linkage or external linkage (<a
href="#Basic.Linkage.Program" data-reference-type="ref"
data-reference="Basic.Linkage.Program">3.6.1</a> and <a
href="#Basic.Linkage.External" data-reference-type="ref"
data-reference="Basic.Linkage.External">3.6.2</a>).</p></li>
</ul>
<h2 id="Basic.lval">Lvalues and rvalues[Basic.lval]</h2>
<p><strong></strong> Expressions are classified by the type(s) of values
they produce. The valid types of values produced by expressions are:</p>
<ol>
<li><p>An <em>lvalue</em> represents a function or object.</p></li>
<li><p>An <em>rvalue</em> represents a temporary object.</p></li>
<li><p>An <em>xvalue</em> (expiring value) represents an object near the
end of its lifetime.</p></li>
<li><p>A <em>cxvalue</em> (casted expiring value) is an <em>xvalue</em>
which, on expiration, assigns its value to a bound
<em>lvalue</em>.</p></li>
<li><p>A <em>glvalue</em> is an <em>lvalue</em>, <em>xvalue</em>, or
<em>cxvalue</em>.</p></li>
<li><p>A <em>prvalue</em> is an <em>rvalue</em> that is not an
<em>xvalue</em>.</p></li>
</ol>
<h1 id="Conv">Standard Conversions[Conv]</h1>
<p><strong></strong> <span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> inherits standard
conversions similar to <span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span>. This chapter
enumerates the full set of conversions. A <em>standard conversion
sequence</em> is a sequence of standard conversions in the following
order:</p>
<ol>
<li><p>Zero or one conversion of either lvalue-to-rvalue, or
array-to-pointer.</p></li>
<li><p>Zero or one conversion of either integral conversion, floating
point conversion, floating point-integral conversion, or boolean
conversion, derived-to-base-lvalue, or flat conversion<a href="#fn14"
class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a>.</p></li>
<li><p>Zero or one conversion of scalar-vector splat, or vector/matrix
truncation. <a href="#fn15" class="footnote-ref" id="fnref15"
role="doc-noteref"><sup>15</sup></a>.</p></li>
<li><p>Zero or one qualification conversion.</p></li>
</ol>
<p>Standard conversion sequences are applied to expressions, if
necessary, to convert it to a required destination type.</p>
<h2 id="Conv.lval">Lvalue-to-rvalue conversion[Conv.lval]</h2>
<p><strong></strong> A glvalue of a non-function type <span>T</span> can
be converted to a prvalue. The program is ill-formed if <span>T</span>
is an incomplete type. If the glvalue refers to an object that is not of
type <span>T</span> and is not an object of a type derived from
<span>T</span>, the program is ill-formed. If the glvalue refers to an
object that is uninitialized, the behavior is undefined. Otherwise the
prvalue is of type <span>T</span>.</p>
<p><strong></strong> If the glvalue refers to an array of type
<span>T</span>, the prvalue will refer to a copy of the array, not
memory referred to by the glvalue.</p>
<h2 id="Conv.array">Array-to-pointer conversion[Conv.array]</h2>
<p><strong></strong> An lvalue or rvalue of type <span>T[]</span>
(unsized array), can be converted to a prvalue of type pointer to
<span>T</span><a href="#fn16" class="footnote-ref" id="fnref16"
role="doc-noteref"><sup>16</sup></a><a href="#fn17" class="footnote-ref"
id="fnref17" role="doc-noteref"><sup>17</sup></a>.</p>
<h2 id="Conv.ipromote">Integral promotion[Conv.ipromote]</h2>
<p><strong></strong> An integral promotion is a conversion of:</p>
<ul>
<li><p>a glvalue of integer type other than <span>bool</span> to a
cxvalue of integer type of higher conversion rank, or</p></li>
<li><p>a conversion of a prvalue of integer type other than bool to a
prvalue of integer type of higher conversion rank, or</p></li>
<li><p>a conversion of a glvalue of type <span>bool</span> to a cxvalue
of integer type, or</p></li>
<li><p>a conversion of a prvalue of type <span>bool</span> to a prvalue
of integer type.</p></li>
</ul>
<p><strong></strong> Integer conversion ranks are defined in section <a
href="#Conv.rank.int" data-reference-type="ref"
data-reference="Conv.rank.int">4.15.1</a>.</p>
<p><strong></strong> A conversion is only a promotion if the destination
type can represent all of the values of the source type.</p>
<h2 id="Conv.fppromote">Floating point promotion[Conv.fppromote]</h2>
<p><strong></strong> A glvalue of a floating point type can be converted
to a cxvalue of a floating point type of higher conversion rank, or a
prvalue of a floating point type can be converted to a prvalue of a
floating point type of higher conversion rank.</p>
<p><strong></strong> Floating point conversion ranks are defined in
section <a href="#Conf.rank.float" data-reference-type="ref"
data-reference="Conf.rank.float">[Conf.rank.float]</a>.</p>
<h2 id="Conv.iconv">Integral conversion[Conv.iconv]</h2>
<p><strong></strong> A glvalue of an integer type can be converted to a
cxvalue of any other non-enumeration integer type. A prvalue of an
integer type can be converted to a prvalue of any other integer
type.</p>
<p><strong></strong> If the destination type is unsigned, integer
conversion maintains the bit pattern of the source value in the
destination type truncating or extending the value to the destination
type.</p>
<p><strong></strong> If the destination type is signed, the value is
unchanged if the destination type can represent the source value. If the
destination type cannot represent the source value, the result is
implementation-defined.</p>
<p><strong></strong> If the source type is <span>bool</span>, the values
<span>true</span> and <span>false</span> are converted to one and zero
respectively.</p>
<h2 id="Conv.fconv">Floating point conversion[Conv.fconv]</h2>
<p><strong></strong> A glvalue of a floating point type can be converted
to a cxvalue of any other floating point type. A prvalue of a floating
point type can be converted to a prvalue of any other floating point
type.</p>
<p><strong></strong> If the source value can be exactly represented in
the destination type, the conversion produces the exact representation
of the source value. If the source value cannot be exactly represented,
the conversion to a best-approximation of the source value is
implementation defined.</p>
<h2 id="Conv.fpint">Floating point-integral conversion[Conv.fpint]</h2>
<p><strong></strong> A glvalue of floating point type can be converted
to a cxvalue of integer type. A prvalue of floating point type can be
converted to a prvalue of integer type. Conversion of floating point
values to integer values truncates by discarding the fractional value.
The behavior is undefined if the truncated value cannot be represented
in the destination type.</p>
<p><strong></strong> A glvalue of integer type can be converted to a
cxvalue of floating point type. A prvalue of integer type can be
converted to a prvalue of floating point type. If the destination type
can exactly represent the source value, the result is the exact value.
If the destination type cannot exactly represent the source value, the
conversion to a best-approximation of the source value is implementation
defined.</p>
<h2 id="Conv.bool">Boolean conversion[Conv.bool]</h2>
<p><strong></strong> A glvalue of arithmetic type can be converted to a
cxvalue of boolean type. A prvalue of arithmetic or unscoped enumeration
type can be converted to a prvalue of boolean type. A zero value is
converted to <span>false</span>; all other values are converted to
<span>true</span>.</p>
<h2 id="Conv.flat">Elementwise conversion[Conv.flat]</h2>
<p><strong></strong> For a given aggregate <span>A</span>, there is a
flattened order of subojects, <span>A<span
class="math inline"><sup>′</sup></span></span>, as described in section
<a href="#Decl.Init.Agg" data-reference-type="ref"
data-reference="Decl.Init.Agg">7.4.1</a>. A prvalue of <span>A</span>,
can be elementwise converted to a prvalue of an aggregate
<span>B</span>, whose flattened form is <span>B<span
class="math inline"><sup>′</sup></span></span>, if the following
conditions are true:</p>
<ul>
<li><p>The length of <span>A<span
class="math inline"><sup>′</sup></span></span>, <span>N</span>, is
greater than or equal to the length of <span>B<span
class="math inline"><sup>′</sup></span></span>, <span>M</span>.</p></li>
<li><p>For every index <span>I</span> from to <span>M-1</span>, there
exists an implicit conversion from <span>A<span
class="math inline"><sup>′</sup></span>[I]</span> to <span>B<span
class="math inline"><sup>′</sup></span>[I]</span>.</p></li>
</ul>
<p><strong></strong> A glvalue of type <span>T[N]</span> can be
converted to a cxvalue of type <span>T</span>.</p>
<p><strong></strong> A glvalue of type <span>T[N]</span> can be
converted to a cxvalue of type <span>T[M]</span>, if <span>N</span> is
greater than <span>M</span>.</p>
<p><strong></strong> A glvalue of type <span>T[N]</span> can be
converted to a cxvalue of type <span>vector&lt;T,M&gt;</span>, if
<span>N</span> is greater than or equal to <span>M</span>.</p>
<p><strong></strong> A glvalue of type <span>vector&lt;T,N&gt;</span>
can be converted to a cxvalue of type <span>T[M]</span>, if
<span>N</span> is greater than or equal to <span>M</span>.</p>
<h2 id="Conv.vsplat">Vector splat conversion[Conv.vsplat]</h2>
<p><strong></strong> A glvalue of type <span>T</span> can be converted
to a cxvalue of type <span>vector&lt;T,x&gt;</span> or a prvalue of type
<span>T</span> can be converted to a prvalue of type
<span>vector&lt;T,x&gt;</span>. The destination value is the source
value replicated into each element of the destination.</p>
<p><strong></strong> A glvalue of type <span>T</span> can be converted
to a cxvalue of type <span>matrix&lt;T,x,y&gt;</span> or a prvalue of
type <span>T</span> can be converted to a prvalue of type
<span>matrix&lt;T,x,y&gt;</span>. The destination value is the source
value replicated into each element of the destination.</p>
<p><strong></strong> A prvalue of type <span>vector&lt;T,1&gt;</span>
can be converted to a prvalue of type <span>vector&lt;T,x&gt;</span>.
The destination value is the value in the source vector replicated into
each element of the destination.</p>
<h2 id="Conv.asplat">Array and Class splat conversion[Conv.asplat]</h2>
<p><strong></strong> A prvalue of type <span>T</span> can be converted
to a prvalue of type <span>struct S</span>, if there are valid
conversions from <span>T</span> to each <span>U</span> in flattened
<span>S</span>, see section <a href="#Decl.init.Agg"
data-reference-type="ref"
data-reference="Decl.init.Agg">[Decl.init.Agg]</a> for description of a
flattened ordering. The destination value is the source value
<span>T</span> replicated into each element of the flattened
<span>S</span>.</p>
<p><strong></strong> A prvalue of type <span>vector&lt;T,1&gt;</span>
can be converted to a prvalue of type <span>struct S</span>, if there
are valid conversions from <span>T</span> to each <span>U</span> in
flattened <span>S</span>. The destination value is the value in the
source vector replicated into each element of the flattened
<span>S</span>.</p>
<p><strong></strong> A prvalue of type <span>T</span> can be converted
to a prvalue of type <span>U[N]</span>, if there are valid conversions
from <span>T</span> to each <span>V</span> in flattened <span>U</span>.
The destination value is the source value <span>T</span> replicated into
each element of the flattened <span>U[N]</span>.</p>
<p><strong></strong> A prvalue of type <span>vector&lt;T,1&gt;</span>
can be converted to a prvalue of type <span>U[N]</span>, if there are
valid conversions from <span>T</span> to each <span>V</span> in
flattened <span>U</span>. The destination value is the value in the
source vector replicated into each element of the flattened
<span>U[N]</span>.</p>
<h2 id="Conv.vtrunc">Vector and matrix truncation
conversion[Conv.vtrunc]</h2>
<p><strong></strong> A prvalue of type <span>vector&lt;T,x&gt;</span>
can be converted to a prvalue of type:</p>
<ul>
<li><p><span>vector&lt;T,y&gt;</span> only if <span
class="math inline"><em>y</em> &lt; <em>x</em></span>, or</p></li>
<li><p><span>T</span></p></li>
</ul>
<p><strong></strong> The resulting value of vector truncation is
comprised of elements <span class="math inline">[0..<em>y</em>)</span>,
dropping elements <span
class="math inline">[<em>y</em>..<em>x</em>)</span>.</p>
<p><strong></strong> A prvalue of type <span>matrix&lt;T,x,y&gt;</span>
can be converted to a prvalue of type:</p>
<ul>
<li><p><span>matrix&lt;T,z,w&gt;</span> only if <span
class="math inline"><em>x</em> ≥ <em>z</em></span> and <span
class="math inline"><em>y</em> ≥ <em>w</em></span>,</p></li>
<li><p><span>vector&lt;T,z&gt;</span> only if <span
class="math inline"><em>x</em> ≥ <em>z</em></span>, or</p></li>
<li><p><span>T</span>.</p></li>
</ul>
<p><strong></strong> Matrix truncation is performed on each row and
column dimension separately. The resulting value is comprised of vectors
<span class="math inline">[0..<em>z</em>)</span> which are each
separately comprised of elements <span
class="math inline">[0..<em>w</em>)</span>. Trailing vectors and
elements are dropped.</p>
<p><strong></strong> Reducing the dimension of a vector to one
(<span>vector&lt;T,1&gt;</span>), can produce either a single element
vector or a scalar of type <span>T</span>. Reducing the rows of a matrix
to one (<span>matrix&lt;T,x,1&gt;</span>), can produce either a single
row matrix, a vector of type <span>vector&lt;T,x&gt;</span>, or a scalar
of type <span>T</span>.</p>
<h2 id="Conv.cwise">Component-wise conversions[Conv.cwise]</h2>
<p><strong></strong> A glvalue of type <span>vector&lt;T,x&gt;</span>
can be converted to a cxvalue of type <span>vector&lt;V,x&gt;</span>, or
a prvalue of type <span>vector&lt;T,x&gt;</span> can be converted to a
prvalue of type <span>vector&lt;V,x&gt;</span>. The source value is
converted by performing the appropriate conversion of each element of
type <span>T</span> to an element of type <span>V</span> following the
rules for standard conversions in chapter <a href="#Conv"
data-reference-type="ref" data-reference="Conv">4</a>.</p>
<p><strong></strong> A glvalue of type <span>matrix&lt;T,x,y&gt;</span>
can be converted to a cxvalue of type <span>matrix&lt;V,x,y&gt;</span>,
or a prvalue of type <span>matrix&lt;T,x,y&gt;</span> can be converted
to a prvalue of type <span>matrix&lt;V,x,y&gt;</span>. The source value
is converted by performing the appropriate conversion of each element of
type <span>T</span> to an element of type <span>V</span> following the
rules for standard conversions in chapter <a href="#Conv"
data-reference-type="ref" data-reference="Conv">4</a>.</p>
<h2 id="Conv.qual">Qualification conversion[Conv.qual]</h2>
<p>A prvalue of type "<em>cv1</em> <span>T</span>" can be converted to a
prvalue of type "<em>cv2</em> <span>T</span>" if type "<em>cv2</em>
<span>T</span>" is more cv-qualified than "<em>cv1</em>
<span>T</span>".</p>
<h2 id="Conv.rank">Conversion Rank[Conv.rank]</h2>
<p><strong></strong> Every integer and floating point type have defined
conversion ranks. These conversion ranks are used to differentiate
between <em>promotions</em> and other conversions (see: <a
href="#Conv.iprom" data-reference-type="ref"
data-reference="Conv.iprom">[Conv.iprom]</a> and <a href="#Conv.fpprom"
data-reference-type="ref"
data-reference="Conv.fpprom">[Conv.fpprom]</a>).</p>
<h3 id="Conv.rank.int">Integer Conversion Rank[Conv.rank.int]</h3>
<ul>
<li><p>No two signed integer types shall have the same conversion rank
even if they have the same representation.</p></li>
<li><p>The rank of a signed integer type shall be greater than the rank
of any signed integer type with a smaller size.</p></li>
<li><p>The rank of any unsigned integer type shall equal the rank of the
corresponding signed integer type.</p></li>
<li><p>The rank of <span>bool</span> shall be less than the rank of all
other standard integer types.</p></li>
<li><p>The rank of a minimum precision integer type shall be less than
the rank of any other minimum precision integer type with a larger
minimum value representation size.</p></li>
<li><p>The rank of a minimum precision integer type shall be less than
the rank of all standard integer types.</p></li>
<li><p>For all integer types <span>T1</span>, <span>T2</span>, and
<span>T3</span>: if <span>T1</span> has greater rank than
<span>T2</span> and <span>T2</span> has greater rank than
<span>T3</span>, then <span>T1</span> shall have greater rank than
<span>T3</span>.</p></li>
</ul>
<h3 id="Conv.rank.float">Floating Point Conversion
Rank[Conv.rank.float]</h3>
<ul>
<li><p>The rank <span>half</span> shall be greater than the rank of
<span>min16float</span>.</p></li>
<li><p>The rank <span>float</span> shall be greater than the rank of
<span>half</span>.</p></li>
<li><p>The rank <span>double</span> shall be greater than the rank of
<span>float</span>.</p></li>
<li><p>For all floating point types <span>T1</span>, <span>T2</span>,
and <span>T3</span>: if <span>T1</span> has greater rank than
<span>T2</span> and <span>T2</span> has greater rank than
<span>T3</span>, then <span>T1</span> shall have greater rank than
<span>T3</span>.</p></li>
</ul>
<h1 id="Expr">Expressions[Expr]</h1>
<p><strong></strong> This chapter defines the formulations of
expressions and the behavior of operators when they are not overloaded.
Only member operators may be overloaded<a href="#fn18"
class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>.
Operator overloading does not alter the rules for operators defined by
this standard.</p>
<p><strong></strong> An expression may also be an <em>unevaluated
operand</em> when it appears in some contexts. An <em>unevaluated
operand</em> is a expression which is not evaluated in the program<a
href="#fn19" class="footnote-ref" id="fnref19"
role="doc-noteref"><sup>19</sup></a>.</p>
<p><strong></strong> Whenever a <em>glvalue</em> appears in an
expression that expects a <em>prvalue</em>, a standard conversion
sequence is applied based on the rules in <a href="#Conv"
data-reference-type="ref" data-reference="Conv">4</a>.</p>
<h2 id="Expr.conv">Usual Arithmetic Conversions[Expr.conv]</h2>
<p><strong></strong> Binary operators for arithmetic and enumeration
type require that both operands are of a common type. When the types do
not match the <em>usual arithmetic conversions</em> are applied to yield
a common type. When <em>usual arithmetic conversions</em> are applied to
vector operands they behave as component-wise conversions (<a
href="#Conv.cwise" data-reference-type="ref"
data-reference="Conv.cwise">4.13</a>). The <em>usual arithmetic
conversions</em> are:</p>
<ul>
<li><p>If either operand is of scoped enumeration type no conversion is
performed, and the expression is ill-formed if the types do not
match.</p></li>
<li><p>If either operand is a <span>vector&lt;T,X&gt;</span>, vector
truncation or scalar extension is performed with the following
rules:</p>
<ul>
<li><p>If both vectors are of the same length, no dimension conversion
is required.</p></li>
<li><p>If one operand is a vector and the other operand is a scalar, the
scalar is extended to a vector via a Splat conversion (<a
href="#Conv.vsplat" data-reference-type="ref"
data-reference="Conv.vsplat">4.10</a>) to match the length of the
vector.</p></li>
<li><p>Otherwise, if both operands are vectors of different lengths, the
vector of longer length is truncated to match the length of the shorter
vector (<a href="#Conv.vtrunc" data-reference-type="ref"
data-reference="Conv.vtrunc">4.12</a>).</p></li>
</ul></li>
<li><p>If either operand is of type <span>double</span> or
<span>vector&lt;double, X&gt;</span>, the other operator shall be
converted to match.</p></li>
<li><p>Otherwise, if either operand is of type <span>float</span> or
<span>vector&lt;float, X&gt;</span>, the other operand shall be
converted to match.</p></li>
<li><p>Otherwise, if either operand is of type <span>half</span> or
<span>vector&lt;half, X&gt;</span>, the other operand shall be converted
to match.</p></li>
<li><p>Otherwise, integer promotions are performed on each scalar or
vector operand following the appropriate scalar or component-wise
conversion (<a href="#Conv" data-reference-type="ref"
data-reference="Conv">4</a>).</p>
<ul>
<li><p>If both operands are scalar or vector elements of signed or
unsigned types, the operand of lesser integer conversion rank shall be
converted to the type of the operand with greater rank.</p></li>
<li><p>Otherwise, if both the operand of unsigned scalar or vector
element type is of greater rank than the operand of signed scalar or
vector element type, the signed operand is converted to the type of the
unsigned operand.</p></li>
<li><p>Otherwise, if the operand of signed scalar or vector element type
is able to represent all values of the operand of unsigned scalar or
vector element type, the unsigned operand is converted to the type of
the signed operand.</p></li>
<li><p>Otherwise, both operands are converted to a scalar or vector type
of the unsigned integer type corresponding to the type of the operand
with signed integer scalar or vector element type.</p></li>
</ul></li>
</ul>
<h2 id="Expr.Primary">Primary Expressions[Expr.Primary]</h2>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>primary-expression</em><span
class="nodecor">:</span></span><br />
* literal<br />
* <span>this</span><br />
* <span>(</span> expression <span>)</span><br />
* id-expression<br />
*</p>
</div>
<h3 id="Expr.Primary.Literal">Literals[Expr.Primary.Literal]</h3>
<p><strong></strong> The type of a <em>literal</em> is determined based
on the grammar forms specified in <a href="#Lex.Literal.Kinds"
data-reference-type="ref"
data-reference="Lex.Literal.Kinds">2.9.1</a>.</p>
<h3 id="Expr.Primary.This">This[Expr.Primary.This]</h3>
<p><strong></strong> The keyword <span>this</span> names a reference to
the implicit object of non-static member functions. The
<span>this</span> parameter is always a <em>prvalue</em> of
non-<em>cv-qualified</em>type. <a href="#fn20" class="footnote-ref"
id="fnref20" role="doc-noteref"><sup>20</sup></a></p>
<p><strong></strong> A <span>this</span> expression shall not appear
outside the declaration of a non-static member function.</p>
<h3 id="Expr.Primary.Paren">Parenthesis[Expr.Primary.Paren]</h3>
<p><strong></strong> An expression (<em>E</em>) enclosed in parenthesis
has the same type, result and value category as <em>E</em> without the
enclosing parenthesis. A parenthesized expression may be used in the
same contexts with the same meaning as the same non-parenthesized
expression.</p>
<h3 id="Expr.Primary.ID">Names[Expr.Primary.ID]</h3>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">The grammar and behaviors of this section
are almost identical to C/C++ with some subtractions (notably lambdas
and destructors).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>id-expression</em><span
class="nodecor">:</span></span><br />
* unqualified-id<br />
* qualified-id</p>
</div>
<h4 id="Expr.Primary.ID.Unqual">Unqualified
Identifiers[Expr.Primary.ID.Unqual]</h4>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>unqualified-id</em><span
class="nodecor">:</span></span><br />
* identifier<br />
* operator-function-id<br />
* conversion-function-id<br />
* template-id<br />
*</p>
</div>
<h4 id="Expr.Primary.ID.Qual">Qualified
Identifiers[Expr.Primary.ID.Qual]</h4>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>qualified-id</em><span
class="nodecor">:</span></span><br />
* nested-name-specifier
<span><span>template</span><sub><em>opt</em></sub></span>
unqualified-id<br />
*</p>
<p><span><em>nested-name-specifier</em><span
class="nodecor">:</span></span><br />
* <span>::</span><br />
* type-name <span>::</span><br />
* namespace-name <span>::</span><br />
* nested-name-specifier identifier <span>::</span><br />
* nested-name-specifier
<span><span>template</span><sub><em>opt</em></sub></span>
simple-template-id <span>::</span></p>
</div>
<h2 id="Expr.Post">Postfix Expressions[Expr.Post]</h2>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>postfix-expression</em><span
class="nodecor">:</span></span><br />
* primary-expression<br />
* postfix-expression [ expression ]<br />
* postfix-expression [ braced-init-list ]<br />
* postfix-expression <span>(</span>
<span>expression-list<sub><em>opt</em></sub></span> <span>)</span><br />
* simple-type-specifier <span>(</span>
<span>expression-list<sub><em>opt</em></sub></span> <span>)</span><br />
* typename-specifier <span>(</span>
<span>expression<sub><em>opt</em></sub></span> <span>)</span><br />
* simple-type-specifier braced-init-list<br />
* typename-specifier braced-init-list<br />
* postfix-expression <span>.</span>
<span><span>template</span><sub><em>opt</em></sub></span>
id-expression<br />
* postfix-expression <span>-&gt;</span>
<span><span>template</span><sub><em>opt</em></sub></span>
id-expression<br />
* postfix-expression <span>++</span><br />
* postfix-expression <span>–</span></p>
</div>
<h2 id="Expr.Post.Subscript">Subscript[Expr.Post.Subscript]</h2>
<p><strong></strong> A <em>postfix-expression</em> followed by an
expression in square brackets () is a subscript expression. In an array
subscript expression of the form <span>E1[E2]</span>, <span>E1</span>
must either be a variable of array, vector, or matrix of
<span>T[]</span>, or an object of type <span>T</span> where
<span>T</span> provides an overloaded implementation of
<span>operator[]</span> (<a href="#Overload" data-reference-type="ref"
data-reference="Overload">8</a>).<a href="#fn21" class="footnote-ref"
id="fnref21" role="doc-noteref"><sup>21</sup></a></p>
<h2 id="Expr.Post.Call">Function Calls[Expr.Post.Call]</h2>
<p><strong></strong> A function call may be an <em>ordinary
function</em>, or a <em>member function</em>. In a function call to an
<em>ordinary function</em>, the <em>postfix-expression</em> must be an
lvalue that refers to a function. In a function call to a <em>member
function</em>, the <em>postfix-expression</em> will be an implicit or
explicit class member access whose <em>id-expression</em> is a member
function name.</p>
<p><strong></strong> When a function is called, each parameter shall be
initialized with its corresponding argument. The order in which
parameters are initialized is unspecified. <a href="#fn22"
class="footnote-ref" id="fnref22"
role="doc-noteref"><sup>22</sup></a></p>
<p><strong></strong> If the function is a non-static member function the
<span>this</span> argument shall be initialized to a reference to the
object of the call as if casted by an explicit cast expression to an
lvalue reference of the type that the function is declared as a member
of.</p>
<p><strong></strong> Parameters are either <em>input parameters</em>,
<em>output parameters</em>, or <em>input/output parameters</em> as
denoted in the called function’s declaration (<a href="#Decl.Function"
data-reference-type="ref" data-reference="Decl.Function">7.5</a>). For
all types of parameters the argument expressions are evaluated before
the function call occurs.</p>
<p><strong></strong> <em>Input parameters</em> are passed by-value into
a function. If an argument to an <em>input parameter</em> is of
constant-sized array type, the array is copied to a temporary and the
temporary value is converted to an address via array-to-pointer decay.
If an argument is an unsized array type, the array lvalue directly
decays via array-to-pointer decay. <a href="#fn23" class="footnote-ref"
id="fnref23" role="doc-noteref"><sup>23</sup></a></p>
<p><strong></strong> Arguments to <em>output</em> and <em>input/output
parameters</em> must be lvalues. <em>Output parameters</em> are not
initialized prior to the call; they are passed as an uninitialized
cxvalue (<a href="#Basic.lval" data-reference-type="ref"
data-reference="Basic.lval">3.9</a>). An <em>output parameter</em> is
only initialized explicitly inside the called function. It is undefined
behavior to not explicitly initialize an <em>output parameter</em>
before returning from the function in which it is defined. The cxvalue
created from an argument to an <em>input/output parameter</em> is
initialized through copy-initialization from the lvalue argument
expression. Overload resolution shall occur on argument initialization
as if the expression <span>T Param = Arg</span> were evaluated. In both
cases, the cxvalue shall have the type of the parameter and the argument
can be converted to that type through implicit or explicit
conversion.</p>
<p><strong></strong> If an argument to an <em>output</em> or
<em>input/output parameter</em> is a constant sized array, the array is
copied to a temporary cxvalue following the same rules for any other
data type. If an argument to an <em>output</em> or <em>input/output
parameter</em> is an unsized array type, the array lvalue directly
decays via array-to-pointer decay. An argument of a constant sized array
of type <span>T[N]</span> can be converted to a cxvalue of an unsized
array of type <span>T[]</span> through array to pointer decay. An
unsized array of type <span>T[]</span>, cannot be implicitly converted
to a a constant sized array of type <span>T[N]</span>.</p>
<p><strong></strong> On expiration of the cxvalue, the value is assigned
back to the argument lvalue expression using a resolved assignment
expression as if the expression <span>Arg = Param</span> were written<a
href="#fn24" class="footnote-ref" id="fnref24"
role="doc-noteref"><sup>24</sup></a>. The argument expression must be of
a type or able to convert to a type that has defined copy-initialization
to and assignment from the parameter type. The lifetime of the cxvalue
begins at argument expression evaluation, and ends after the function
returns. A cxvalue argument is passed by-address to the caller.</p>
<p><strong></strong> If the lvalue passed to an <em>output</em> or
<em>input/output parameter</em> does not alias any other parameter
passed to that function, an implementation may avoid the creation of
excess temporaries by passing the address of the lvalue instead of
creating the cxvalue.</p>
<p><strong></strong> When a function is called, any parameter of object
type must have completely defined type, and any parameter of array of
object type must have completely defined element type.<a href="#fn25"
class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>
The lifetime of a parameter ends on return of the function in which it
is defined.<a href="#fn26" class="footnote-ref" id="fnref26"
role="doc-noteref"><sup>26</sup></a> Initialization and destruction of
each parameter occurs within the context of the calling function.</p>
<p><strong></strong> The value of a function call is the value returned
by the called function.</p>
<p><strong></strong> A function call is an lvalue if the result type is
an lvalue reference type; otherwise it is a prvalue.</p>
<p><strong></strong> If a function call is a prvalue of object type, the
type of the prvalue must be complete.</p>
<h1 id="Stmt">Statements[Stmt]</h1>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>statement</em><span class="nodecor">:</span></span><br />
* labeled-statement<br />
* <span>attribute-specifier-sequence<sub><em>opt</em></sub></span>
expression-statement<br />
* <span>attribute-specifier-sequence<sub><em>opt</em></sub></span>
compound-statement<br />
* <span>attribute-specifier-sequence<sub><em>opt</em></sub></span>
iteration-statement<br />
* <span>attribute-specifier-sequence<sub><em>opt</em></sub></span>
selection-statement<br />
* declaration-statement</p>
</div>
<h2 id="Stmt.Label">Label Statements[Stmt.Label]</h2>
<p><strong></strong> The optional <em>attribute-specifier-sequence</em>
applies to the statement that immediately follows it.</p>
<h2 id="Stmt.Attr">Attributes[Stmt.Attr]</h2>
<h3 id="Stmt.Attr.Unroll">Unroll Attribute[Stmt.Attr.Unroll]</h3>
<p><strong></strong> The <em>[unroll]</em> attribute is only valid when
applied to <em>iteration-statements</em>. It is used to indicate that
<em>iteration-statements</em> like <span>for</span>, <span>while</span>
and <span>do while</span> can be unrolled. This attribute qualifier can
be used to specify full unrolling or partial unrolling by a specified
amount. This is a compiler hint and the compiler may ignore this
directive.</p>
<p><strong></strong> The unroll attribute may optionally have an unroll
factor represented as a single argument <span>n</span> that is an
integer constant expression value greater than zero. If n is not
specified, the compiler determines the unrolling factor for the loop.
The <em>[unroll]</em> attribute can not be applied to the same
<em>iteration-statement</em> as the attribute.</p>
<h3 id="Stmt.Attr.Loop">Loop Attribute[Stmt.Attr.Loop]</h3>
<p><strong></strong> The Attribute tells the compiler to execute each
iteration of the loop. In other words, its a hint to indicate a loop
should not be unrolled. Therefore it is not compatible with the
attribute.</p>
<h1 id="Decl">Declarations[Decl]</h1>
<h2 id="Decl.Pre">Preamble[Decl.Pre]</h2>
<p><strong></strong> Declarations generally specify how names are to be
interpreted. Declarations have the form</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>declaration-seq</em><span
class="nodecor">:</span></span><br />
* <em>declaration</em><br />
* <em>declaration-seq declaration</em></p>
<p><span><em>declaration</em><span class="nodecor">:</span></span><br />
* <em>name-declaration</em><br />
* <em>special-declaration</em><br />
* <em>empty-declaration</em></p>
<p><span><em>name-declaration</em><span
class="nodecor">:</span></span><br />
* <em>variable-declaration</em><br />
* <em>function-declaration</em><br />
* <em>namespace-declaration</em><br />
* <em>record-declaration</em><br />
* <em>template-declaration</em><br />
* <em>type-alias-declaration</em><br />
* ...</p>
<p><span><em>special-declaration</em><span
class="nodecor">:</span></span><br />
* <em>export-declaration-group</em><br />
* <em>cbuffer-declaration-group</em><br />
* ...</p>
<p><span><em>empty-declaration</em><span class="nodecor">:</span></span>
<span>;</span></p>
</div>
<h2 id="Decl.Spec">Specifiers[Decl.Spec]</h2>
<h3 id="Decl.Spec.General">General[Decl.Spec.General]</h3>
<p><strong></strong> The specifiers that can be used in a declaration
are</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>decl-specifier</em><span
class="nodecor">:</span></span><br />
* <em>function-specifier</em><br />
* ...</p>
</div>
<h3 id="Decl.Spec.Fct">Function specifiers[Decl.Spec.Fct]</h3>
<p><strong></strong> A <em>function-specifier</em> can be used only in a
function declaration.</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>function-specifier</em><span
class="nodecor">:</span></span><br />
* <span>export</span><br />
*</p>
</div>
<p><strong></strong> The <span>export</span> specifier denotes that the
function has program linkage (<a href="#Basic.Linkage.Program"
data-reference-type="ref"
data-reference="Basic.Linkage.Program">3.6.1</a>).</p>
<p><strong></strong> The <span>export</span> specifier cannot be used on
functions directly or indirectly within an unnamed namespace.</p>
<p><strong></strong> Functions with program linkage can also be
specified in <em>export-declaration-group</em> (<a href="#Decl.Export"
data-reference-type="ref" data-reference="Decl.Export">7.7</a>).</p>
<p><strong></strong> If a function is declared with an
<span>export</span> specifier then all redeclarations of the same
function must also use the <span>export</span> specifier or be part of
<em>export-declaration-group</em> (<a href="#Decl.Export"
data-reference-type="ref" data-reference="Decl.Export">7.7</a>).</p>
<h2 id="Decl.Decl">Declarators[Decl.Decl]</h2>
<h2 id="Decl.Init">Initializers[Decl.Init]</h2>
<p><strong></strong> The process of initialization described in this
section applies to all initializers regardless of the context.</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>initializer</em><span class="nodecor">:</span></span><br />
* brace-or-equal-initializer<br />
* <span>(</span> expression-list <span>)</span><br />
*</p>
<p><span><em>brace-or-equal-initializer</em><span
class="nodecor">:</span></span><br />
* <span>=</span> initializer-clause<br />
* braced-init-list<br />
*</p>
<p><span><em>initializer-clause</em><span
class="nodecor">:</span></span><br />
* assignment-expression<br />
* braced-init-list<br />
*</p>
<p><span><em>braced-init-list</em><span
class="nodecor">:</span></span><br />
* <span>{</span> initializer-list
<span><span>,</span><sub><em>opt</em></sub></span> <span>}</span><br />
* <span>{</span> <span>}</span><br />
*</p>
<p><span><em>initializer-list</em><span
class="nodecor">:</span></span><br />
* initializer-clause<br />
* initializer-list <span>,</span> initializer-clause<br />
*</p>
</div>
<h3 id="Decl.Init.Agg">Aggregate Initialization[Decl.Init.Agg]</h3>
<p><strong></strong> An <em>aggregate</em> is a vector, matrix, array,
or class.</p>
<p><strong></strong> The subobjects of an aggregate have a defined
order. For vectors and arrays the order is increasing subscript order.
For matrices it is increasing subscript order with the subscript nesting
such that in the notation <span>Mat[M][N]</span>, the ordering is <span
class="math inline"><em>M</em><em>a</em><em>t</em>[0][0]...<em>M</em><em>a</em><em>t</em>[0][<em>N</em>]...<em>M</em><em>a</em><em>t</em>[<em>M</em>][0]...<em>M</em><em>a</em><em>t</em>[<em>M</em>][<em>N</em>]</span>.
For classes the order is base class, followed by member subobjects in
declaration order.</p>
<p><strong></strong> A <em>flattened ordering</em> of subobjects can be
produced by performing a depth-first traversal of the subobjects of an
object following the defined subobject ordering.</p>
<p><strong></strong> Each <em>braced initializer list</em> is comprised
of zero or more <em>initializer-clause</em> expressions, which is either
another braced initializer list or an expression which generates a value
that either is or can be implicitly converted to an rvalue. Each
assignment-expression is an object, which may be a scalar or aggregate
type. A <em>flattened initializer sequence</em> is a sequence of
expressions constructed by a depth-first traversal over each
assignment-expression in an initializer-list and performing a
depth-first traversal accessing each subobject of the
assignment-expression.</p>
<p><strong></strong> If the target object is an array of unknown size,
the object is assumed to have <span
class="math inline"><em>m</em></span> possible elements during parsing,
where <span class="math inline"><em>m</em> &gt; 0</span>.</p>
<p><strong></strong> An initializer-list is a valid initializer if for
each element <span
class="math inline"><em>E</em><sub><em>n</em> mod  <em>m</em></sub></span>
in the target object’s flattened ordering there is a corresponding
expression <span
class="math inline"><em>E</em><sub><em>n</em></sub></span> in the
flattened initializer sequence, which can be implicitly converted to the
element’s type. For arrays of unknown size, the total number of
expressions in the flattened initializer sequence must be a multiple of
the array’s base element type.</p>
<p><strong></strong> An initializer-list is invalid if the flattened
initializer sequence contains more or fewer elements than the target
object’s flattened ordering, or if any initializer <span
class="math inline"><em>I</em><sub><em>n</em></sub></span> cannot be
implicitly converted to the corresponding element <span
class="math inline"><em>E</em><sub><em>n</em></sub></span>’s type.</p>
<h2 id="Decl.Function">Function Definitions[Decl.Function]</h2>
<h2 id="Decl.Attr">Attributes[Decl.Attr]</h2>
<h3 id="Decl.Attr.Semantic">Semantic
Annotations[Decl.Attr.Semantic]</h3>
<h3 id="Decl.Attr.Entry">Entry Attributes[Decl.Attr.Entry]</h3>
<h2 id="Decl.Export">Export Declarations[Decl.Export]</h2>
<p><strong></strong> One or more functions with <em>external
linkage</em> can be also specified in the form of</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>export-declaration-group</em><span
class="nodecor">:</span></span><br />
* <span>export</span> <span>{</span>
<span>function-declaration-seq<sub><em>opt</em></sub></span>
<span>}</span><br />
*</p>
<p><span><em>function-declaration-seq</em><span
class="nodecor">:</span></span><br />
* <em>function-declaration</em>
<span>function-declaration-seq<sub><em>opt</em></sub></span></p>
</div>
<p><strong></strong> The <span>export</span> specifier denotes that
every <em>function-declaration</em> included in
<em>function-declaration-seq</em> has <em>external linkage</em> (<a
href="#Basic.Linkage.External" data-reference-type="ref"
data-reference="Basic.Linkage.External">3.6.2</a>).</p>
<p><strong></strong> The <em>export-declaration-group</em> declaration
cannot appear directly or indirectly within an unnamed namespace.</p>
<p><strong></strong> Functions with <em>external linkage</em> can also
be declared with an <span>export</span> specifier (<a
href="#Decl.Spec.Fct" data-reference-type="ref"
data-reference="Decl.Spec.Fct">7.2.2</a>).</p>
<p><strong></strong> If a function is part of an
<em>export-declaration-group</em> then all redeclarations of the same
function must also be part on a <em>export-declaration-group</em> or be
declared with an <span>export</span> specifier (<a href="#Decl.Spec.Fct"
data-reference-type="ref" data-reference="Decl.Spec.Fct">7.2.2</a>).</p>
<h1 id="Overload">Overloading[Overload]</h1>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong></strong> HLSL inherits much of
its overloading behavior from C++. This chapter is extremely similar to
<span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span> clause
<strong>[over]</strong>. Notable differences exist around HLSL’s
parameter modifier keywords, program entry points, and overload
conversion sequence ranking.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<p><strong></strong> When a single name is declared with two or more
different declarations in the same scope, the name is
<em>overloaded</em>. A declaration that declares an overloaded name is
called an <em>overloaded declaration</em>. The set of overloaded
declarations that declare the same overloaded name are that name’s
<em>overload set</em>.</p>
<p><strong></strong> Only function and template declarations can be
overloaded; variable and type declarations cannot be overloaded.</p>
<h2 id="Overload.Decl">Overloadable Declarations[Overload.Decl]</h2>
<p><strong></strong> This section specifies the cases in which a
function declaration cannot be overloaded. Any program that contains an
invalid overload set is ill-formed.</p>
<p><strong></strong> In overload set is invalid if:</p>
<ul>
<li><p>One or more declaration in the overload set only differ by return
type.</p>
<div class="HLSL">
<p>int Yeet(); uint Yeet(); // ill-formed: decls differ only by return
type</p>
</div></li>
<li><p>An overload set contains more than one member function
declarations with the same <em>parameter-type-list</em>, and one of
those declarations is a <span>static</span> member function declaration
(<a href="#Classes.Static" data-reference-type="ref"
data-reference="Classes.Static">10.1</a>).</p>
<div class="HLSL">
<p>class Doggo</p>
<p>static void pet(); void pet(); // ill-formed: static pet has the same
parameter-type-list void pet() const; // ill-formed: static pet has the
same parameter-type-list</p>
<p>void wagTail(); // valid: no conflicting static declaration. void
wagTail() const; // valid: no conflicting static declaration.</p>
<p>static void bark(Doggo D); void bark(); // valid: static bark
parameter-type-list is different void bark() const; // valid: static
bark parameter-type-list is different</p>
<p>;</p>
</div></li>
<li><p>An overload set contains more than one entry function declaration
(<a href="#Decl.Attr.Entry" data-reference-type="ref"
data-reference="Decl.Attr.Entry">7.6.2</a>).</p>
<div class="HLSL">
<p>void VS(); void VS(int); // valid: only one entry point.</p>
<p>[shader("vertex")] void Entry();</p>
<p>[shader("compute")] void Entry(int); // ill-formed: an overload set
cannot have more than one entry function</p>
</div></li>
<li><p>An overload set contains more than one function declaration which
only differ in parameter declarations of equivalent types.</p>
<div class="HLSL">
<p>void F(int4 I); void F(vector&lt;int, 4&gt; I); // ill-formed: int4
is a type alias of vector&lt;int, 4&gt;</p>
</div></li>
<li><p>An overload set contains more than one function declaration which
only differ in <span>const</span> specifiers.</p>
<div class="HLSL">
<p>void G(int); void G(const int); // ill-formed: redeclaration of
G(int) void G(int) void G(const int) // ill-formed: redefinition of
G(int)</p>
</div></li>
<li><p>An overload set contains more than one function declaration which
only differ in parameters mismatching <span>out</span> and
<span>inout</span>.</p>
<div class="HLSL">
<p>void H(int); void H(in int); // valid: redeclaration of H(int) void
H(inout int); // valid: overloading between in and inout is allowed</p>
<p>void I(in int); void I(out int); // valid: overloading between in and
out is allowed</p>
<p>void J(out int); void J(inout int); // ill-formed: Cannot overload
based on out/inout mismatch</p>
</div></li>
</ul>
<h2 id="Overload.Res">Overload Resolution[Overload.Res]</h2>
<p><strong></strong> <em>Overload resolution</em> is process by which a
function call is mapped to a the best overloaded function declaration.
Overload resolution uses set of functions called the <em>candidate
set</em>, and a list of expressions that comprise the argument list for
the call.</p>
<p><strong></strong> Overload resolution selects the function to call in
the following contexts<a href="#fn27" class="footnote-ref" id="fnref27"
role="doc-noteref"><sup>27</sup></a>:</p>
<ul>
<li><p>invocation of a function named in a function call
expression;</p></li>
<li><p>invocation of a function call operator on a class object named in
function call syntax;</p></li>
<li><p>invocation of the operator referenced in an expression;</p></li>
<li><p>invocation of a user-defined conversion for copy-initialization
of a class object;</p></li>
<li><p>invocation of a conversion function for initialization of an
object of a nonclass type from an expression of class type.</p></li>
</ul>
<p><strong></strong> In each of these contexts a unique method is used
to construct the overload candidate set and argument expression
list.</p>
<h3 id="Overload.Res.Sets">Candidate Functions and Argument
Lists[Overload.Res.Sets]</h3>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span data-acronym-label="isoCPP"
data-acronym-form="singular+short">isoCPP</span> goes into a lot of
detail in this section about how candidate functions and argument lists
are selected for each context where overload resolution is performed.
HLSL matches C++ for the contexts that HLSL inherits. For now, this
section will be left as a stub, but HLSL inherits the following sections
from C++:</p>
<ul>
<li><p><strong>[over.call.func]</strong></p></li>
<li><p><strong>[over.call.object]</strong></p></li>
<li><p><strong>[over.match.oper]</strong></p></li>
<li><p><strong>[over.match.copy]</strong></p></li>
<li><p><strong>[over.match.conv]</strong></p></li>
</ul></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Overload.Res.Viable">Viable Functions[Overload.Res.Viable]</h3>
<p><strong></strong> Given the candidate set and argument expressions as
determined by the relevant context (<a href="#Overload.Res.Sets"
data-reference-type="ref" data-reference="Overload.Res.Sets">8.2.1</a>),
a subset of viable functions can be selected from the candidate set.</p>
<p><strong></strong> A function candidate <span
class="math inline"><em>F</em>(<em>P</em><sub>0</sub>...<em>P</em><sub><em>m</em></sub>)</span>
is not a viable function for a call with argument list <span
class="math inline"><em>A</em><sub>0</sub>...<em>A</em><sub><em>n</em></sub></span>
if:</p>
<ul>
<li><p>The function has fewer parameters than there are arguments in the
argument list (<span
class="math inline"><em>m</em> &lt; <em>n</em></span>).</p></li>
<li><p>The function has more parameters than there are arguments to the
argument list (<span
class="math inline"><em>m</em> &gt; <em>n</em></span>), and function
parameters <span
class="math inline"><em>P</em><sub><em>n</em> + 1</sub>...<em>P</em><sub><em>m</em></sub></span>
do not all have default arguments.</p></li>
<li><p>There is not an implicit conversion sequence that converts each
argument <span
class="math inline"><em>A</em><sub><em>i</em></sub></span> to the type
of the corresponding parameter <span
class="math inline"><em>P</em><sub><em>i</em></sub></span>.</p></li>
</ul>
<h3 id="Overload.Res.Best">Best Viable Function[Overload.Res.Best]</h3>
<p><strong></strong> For an overloaded call with arguments <span
class="math inline"><em>A</em><sub>0</sub>...<em>A</em><sub><em>n</em></sub></span>,
each viable function <span
class="math inline"><em>F</em>(<em>P</em><sub>0</sub>...<em>P</em><sub><em>m</em></sub>)</span>,
has a set of implicit conversion sequences <span
class="math inline"><em>I</em><em>C</em><em>S</em><sub>0</sub>(<em>F</em>)...<em>I</em><em>C</em><em>S</em><sub><em>m</em></sub>(<em>F</em>)</span>
defining the conversion sequences for each argument <span
class="math inline"><em>A</em><sub><em>i</em></sub></span> to the type
of parameter <span
class="math inline"><em>P</em><sub><em>i</em></sub></span>.</p>
<p><strong></strong> A viable function <span
class="math inline"><em>F</em></span> is defined to be a better function
than another viable function <span class="math inline">$F`$</span> if
for all arguments <span
class="math inline"><em>I</em><em>C</em><em>S</em><sub><em>i</em></sub>(<em>F</em>)</span>
is not a worse conversion sequence than <span
class="math inline">$ICS_i(F`)$</span>, and:</p>
<ul>
<li><p>for some argument <span class="math inline"><em>j</em></span>,
<span
class="math inline"><em>I</em><em>C</em><em>S</em><sub><em>j</em></sub>(<em>F</em>)</span>
is a better conversion than <span class="math inline">$ICS_j(F`)$</span>
or,</p></li>
<li><p>in the context of an initialization by user-defined conversion,
the conversion sequence from the return type of <span
class="math inline"><em>F</em></span> to the destination type is a
better conversion sequence than the return type of <span
class="math inline">$F`$</span> to the destination type or,</p></li>
<li><p><span class="math inline"><em>F</em></span> is a non-template
function and <span class="math inline">$F`$</span> is a function
template specialization, or</p></li>
<li><p><span class="math inline"><em>F</em></span> and <span
class="math inline">$F`$</span> are both function template
specializations and <span class="math inline"><em>F</em></span> is more
specialized than <span class="math inline">$F`$</span> according to
function template partial ordering rules (<a href="#Template.Func.Order"
data-reference-type="ref"
data-reference="Template.Func.Order">11.2</a>).</p></li>
</ul>
<p><strong></strong> If there is one viable function that is a better
function than all the other viable functions, it is the selected
function; otherwise the call is ill-formed.</p>
<p><strong></strong> If the resolved overload is a function with
multiple declarations, and if at least two of these declarations specify
a default argument that made the function viable, the program is
ill-formed.</p>
<div class="HLSL">
<p>void F(int X = 1); void F(float Y = 2.0f);</p>
<p>void Fn() <span> F(1); // Okay. F(3.0f); // Okay. F(); // Ill-formed.
</span></p>
</div>
<h3 id="Overload.ICS">Implicit Conversion Sequences[Overload.ICS]</h3>
<p><strong></strong> An <em>implicit conversion sequence</em> is a
sequence of conversions which converts a source value to a prvalue of
destination type. In overload resolution the source value is the
argument expression in a function call, and the destination type is the
type of the corresponding parameter of the function being called.</p>
<p><strong></strong> When a parameter is a cxvalue an <em>inverted
implicit conversion sequence</em> is required to convert the parameter
type back to the argument type for writing back to the argument
expression lvalue. An inverted implicit conversion sequence must be a
well-formed implicit conversion sequence where the source value is the
implicit cxvalue of the parameter type, and the destination type is the
argument expression’s lvalue type.</p>
<p><strong></strong> A well-formed implicit conversion sequence is
either a <em>standard conversion sequence</em>, or a <em>user-defined
conversion sequence</em>.</p>
<p><strong></strong> In the following contexts an implicit conversion
sequence can only be a standard conversion sequence:</p>
<ul>
<li><p>Argument conversion for a user-defined conversion
function.</p></li>
<li><p>Copying a temporary for class copy-initialization.</p></li>
<li><p>When passing an initializer-list as a single argument.</p></li>
<li><p>Copy-initialization of a class by user-defined
conversion.</p></li>
</ul>
<p><strong></strong> An implicit conversion sequence models a
copy-initialization unless it is an inverted implicit conversion
sequence when it models an assignment. Any difference in top-level
cv-qualification is handled by the copy-initialization or assignment,
and does not constitute a conversion<a href="#fn28" class="footnote-ref"
id="fnref28" role="doc-noteref"><sup>28</sup></a>.</p>
<p><strong></strong> When the source value type and the destination type
are the same, the implicit conversion sequence is an <em>identity
conversion</em>, which signifies no conversion.</p>
<p><strong></strong> Only standard conversion sequences that do not
create temporary objects are valid for implicit object parameters or
left operand to assignment operators.</p>
<p><strong></strong> If no sequence of conversions can be found to
convert a source value to the destination type, an implicit conversion
sequence cannot be formed.</p>
<p><strong></strong> If several different sequences of conversions exist
that convert the source value to the destination type, the implicit
conversion sequence is defined to be the unique conversion sequence
designated the <em>ambiguous conversion sequence</em>. For the purpose
of ranking implicit conversion sequences, the ambiguous conversion
sequence is treated as a user-defined sequence that is indistinguishable
from any other user-defined conversion sequence. If overload resolution
selects a function using the ambiguous conversion sequence as the best
match for a call, the call is ill-formed.</p>
<h4 id="Overload.ICS.SCS">Standard Conversion
Sequences[Overload.ICS.SCS]</h4>
<p><strong></strong> The conversions that comprise a standard conversion
sequence and the composition of the sequence are defined in Chapter <a
href="#Conv" data-reference-type="ref" data-reference="Conv">4</a>.</p>
<p><strong></strong> Each standard conversion is given a category and
rank as defined in the table below:</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Conversion</th>
<th style="text-align: center;">Category</th>
<th style="text-align: center;">Rank</th>
<th style="text-align: center;">Reference</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">No conversion</td>
<td style="text-align: center;">Identity</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p><span>1-2</span></p>
<p>Lvalue-to-rvalue</p></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><a href="#Conv.lval"
data-reference-type="ref" data-reference="Conv.lval">4.1</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span>4-4</span> Array-to-pointer</td>
<td style="text-align: center;">Lvalue Transformation</td>
<td style="text-align: center;">Exact Match</td>
<td style="text-align: center;"><a href="#Conv.array"
data-reference-type="ref" data-reference="Conv.array">4.2</a></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span>1-2</span> Qualification</td>
<td style="text-align: center;">Qualification Adjustment</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><a href="#Conv.qual"
data-reference-type="ref" data-reference="Conv.qual">4.14</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p><span>1-4</span></p>
<p>Scalar splat (without conversion)</p></td>
<td style="text-align: center;">Scalar Extension</td>
<td style="text-align: center;">Extension</td>
<td style="text-align: center;"><a href="#Conv.vsplat"
data-reference-type="ref" data-reference="Conv.vsplat">4.10</a></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p><span>1-4</span></p>
<p>Integral promotion</p></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><a href="#Conv.iconv"
data-reference-type="ref" data-reference="Conv.iconv">4.5</a> &amp; <a
href="#Conv.rank.int" data-reference-type="ref"
data-reference="Conv.rank.int">4.15.1</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span>1-1</span> Floating point
promotion</td>
<td style="text-align: center;">Promotion</td>
<td style="text-align: center;">Promotion</td>
<td style="text-align: center;"><a href="#Conv.fconv"
data-reference-type="ref" data-reference="Conv.fconv">4.6</a> &amp; <a
href="#Conv.rank.float" data-reference-type="ref"
data-reference="Conv.rank.float">4.15.2</a></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span>1-1</span> Component-wise
promotion</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><a href="#Conv.cwise"
data-reference-type="ref" data-reference="Conv.cwise">4.13</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p><span>1-4</span></p>
<p>Scalar splat promotion</p></td>
<td style="text-align: center;">Scalar Extension Promotion</td>
<td style="text-align: center;">Promotion Extension</td>
<td style="text-align: center;"><a href="#Conv.vsplat"
data-reference-type="ref" data-reference="Conv.vsplat">4.10</a></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p><span>1-4</span></p>
<p>Integral conversion</p></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><a href="#Conv.iconv"
data-reference-type="ref" data-reference="Conv.iconv">4.5</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span>1-1</span> Floating point
conversion</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><a href="#Conv.fconv"
data-reference-type="ref" data-reference="Conv.fconv">4.6</a></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span>1-1</span> Floating-integral
conversion</td>
<td style="text-align: center;">Conversion</td>
<td style="text-align: center;">Conversion</td>
<td style="text-align: center;"><a href="#Conv.fpint"
data-reference-type="ref" data-reference="Conv.fpint">4.7</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span>1-1</span> Boolean conversion</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><a href="#Conv.bool"
data-reference-type="ref" data-reference="Conv.bool">4.8</a></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span>1-1</span> Component-wise
conversion</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><a href="#Conv.cwise"
data-reference-type="ref" data-reference="Conv.cwise">4.13</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p><span>1-4</span></p>
<p>Scalar splat conversion</p></td>
<td style="text-align: center;">Scalar Extension Conversion</td>
<td style="text-align: center;">Conversion Extension</td>
<td style="text-align: center;"><a href="#Conv.vsplat"
data-reference-type="ref" data-reference="Conv.vsplat">4.10</a></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p><span>1-4</span></p>
<p>Vector truncation (without conversion)</p></td>
<td style="text-align: center;">Dimensionality Reduction</td>
<td style="text-align: center;">Truncation</td>
<td style="text-align: center;"><a href="#Conv.vtrunc"
data-reference-type="ref" data-reference="Conv.vtrunc">4.12</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><p><span>1-4</span></p>
<p>Vector truncation promotion</p></td>
<td style="text-align: center;">Dimensionality Reduction Promotion</td>
<td style="text-align: center;">Promotion Truncation</td>
<td style="text-align: center;"><a href="#Conv.vtrunc"
data-reference-type="ref" data-reference="Conv.vtrunc">4.12</a></td>
</tr>
<tr class="even">
<td style="text-align: center;"><p><span>1-4</span></p>
<p>Vector truncation conversion</p></td>
<td style="text-align: center;">Dimensionality Reduction Conversion</td>
<td style="text-align: center;">Conversion Truncation</td>
<td style="text-align: center;"><a href="#Conv.vtrunc"
data-reference-type="ref" data-reference="Conv.vtrunc">4.12</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span>1-4</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p><strong></strong> If a scalar splat conversion occurs in a conversion
sequence where all other conversions are <strong>Exact Match</strong>
rank, the conversion is ranked as <strong>Extension</strong>. If a
scalar splat occurs in a conversion sequence with a
<strong>Promotion</strong> conversion, the conversion is ranked as
<strong>Promotion Extension</strong>. If a scalar splat occurs in a
conversion sequence with a <strong>Conversion</strong> conversion, the
conversion is ranked as <strong>Conversion Extension</strong>.</p>
<p><strong></strong> If a vector truncation conversion occurs in a
conversion sequence where all other conversions are <strong>Exact
Match</strong> rank, the conversion is ranked as
<strong>Truncation</strong>. If a vector truncation occurs in a
conversion sequence with a <strong>Promotion</strong> conversion, the
conversion is ranked as <strong>Promotion Truncation</strong>. If a
vector truncation occurs in a conversion sequence with a
<strong>Conversion</strong> conversion, the conversion is ranked as
<strong>Conversion Truncation</strong>.</p>
<p><strong></strong> Otherwise, the rank of a conversion sequence is
determined by considering the rank of each conversion.</p>
<p><strong></strong> Conversion sequence ranks are ordered from better
to worse as:</p>
<ol>
<li><p><strong>Exact Match</strong></p></li>
<li><p><strong>Extension</strong></p></li>
<li><p><strong>Promotion</strong></p></li>
<li><p><strong>Promotion Extension</strong></p></li>
<li><p><strong>Conversion</strong></p></li>
<li><p><strong>Conversion Extension</strong></p></li>
<li><p><strong>Truncation</strong></p></li>
<li><p><strong>Promotion Truncation</strong></p></li>
<li><p><strong>Conversion Truncation</strong></p></li>
</ol>
<h4 id="Overload.ICS.Comparing">Comparing Implicit Conversion
Sequences[Overload.ICS.Comparing]</h4>
<p><strong></strong> A partial ordering of implicit conversion sequences
exists based on defining relationships for <em>better conversion
sequence</em>, and <em>better conversion</em>. If an implicit conversion
sequence <span
class="math inline"><em>I</em><em>C</em><em>S</em>(<em>f</em>)</span> is
a better conversion sequence than <span
class="math inline">$ICS(f`)$</span>, then the inverse is also true:
<span class="math inline">$ICS(f`)$</span> is a <em>worse conversion
sequence</em> than <span
class="math inline"><em>I</em><em>C</em><em>S</em>(<em>f</em>)</span>.
If <span
class="math inline"><em>I</em><em>C</em><em>S</em>(<em>f</em>)</span> is
neither better nor worse than <span
class="math inline">$ICS(f`)$</span>, the conversion sequences are
<em>indistinguishable conversion sequences</em>.</p>
<p><strong></strong> A standard conversion sequence is always better
than a user-defined conversion sequence.</p>
<p><strong></strong> Standard conversion sequences are ordered by their
ranks. Two conversion sequences with the same rank are indistinguishable
unless one of the following rules applies:</p>
<ul>
<li><p>If class <span>B</span> is derived directly or indirectly from
class <span>A</span> and class <span>C</span> is derived directly or
indirectly from class <span>B</span>,</p>
<ul>
<li><p>binding of a expression of type <span>C</span> to a cxvalue of
type <span>B</span> is better than binding an expression of type
<span>C</span> to a cxvalue of type <span>A</span>,</p></li>
<li><p>conversion of <span>C</span> to <span>B</span> is better than
conversion or <span>C</span> to <span>A</span>,</p></li>
<li><p>binding of a expression of type <span>B</span> to a cxvalue of
type <span>A</span> is better than binding an expression of type
<span>C</span> to a cxvalue of type <span>A</span>,</p></li>
<li><p>conversion of <span>B</span> to <span>A</span> is better than
conversion of <span>C</span> to <span>A</span>.</p></li>
</ul></li>
</ul>
<h1 id="Resources">Resource Types[Resources]</h1>
<p>Resources are built-in intangible types representing memory with an
external interface.</p>
<p>These take the form of Typed Buffers, Raw Buffers, Textures, Constant
Buffers and Samplers.</p>
<p>Buffer and Texture types can be read-only or writable.</p>
<h2 id="Resources.tybufs">Typed Buffers[Resources.tybufs]</h2>
<p>The typed buffer class template represents a one-dimensional resource
containing an array of a single given type. Its contents are indexed by
typed access to each element Types may have their formats converted upon
load.</p>
<p>The element type may be any type up to 16 bytes in size. Elements may
be padded to 16 bytes if the element type is smaller than 16 bytes.</p>
<p>All typed buffers can be read through subscript operators or Load
methods. Writable typed buffers can be written through subscript
operators.</p>
<p>Where <span>T</span> can be any arithmetic type <a
href="#Basic.types.arithmetic" data-reference-type="ref"
data-reference="Basic.types.arithmetic">3.8.1</a> or a vector with a
maximum of four elements containing such an arithmetic type. The total
size of a single contained element must be less than 16 bytes.</p>
<p>Typed buffers perform format conversions on load such that the
underlying data gets converted to the destination type.</p>
<h3 id="Resources.tybufs.ctrs">Constructors[Resources.tybufs.ctrs]</h3>
<p>Read-only Buffers can be defined with explicit or implicit template
parameter types.</p>
<div class="HLSL">
<p>Buffer buf1; Buffer&lt;&gt; buf2; Buffer&lt;float4&gt; buf3;</p>
</div>
<p>Since <span>float4</span> is the default type, all of these
definitions are equivalent.</p>
<p>RWBuffers must be defined with explicit template parameter types.</p>
<div class="HLSL">
<p>RWBuffer&lt;float4&gt; buf;</p>
</div>
<p>When defined at global scope, typed buffers are bound to
externally-defined backing stores using the explicit binding location if
provided or the implicit binding if not (<a href="#Resources.binding"
data-reference-type="ref"
data-reference="Resources.binding">9.8</a>).</p>
<p>When defined at local scope, typed buffers represent local references
that can be associated with global buffers when assigned, but must be
resolvable to a unique global buffer declaration.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">In the case of a buffer array declaration,
a unique global declaration references all the buffers in the array.
Local buffer assignments can map to different resource array elements
depending on runtime values.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<div class="HLSL">
<p>Buffer&lt;int&gt; grobuf; RWBuffer&lt;int&gt; grwbuf; void main()
<span> Buffer&lt;int&gt; lrobuf = grobuf; RWBuffer&lt;int&gt; lrwbuf =
grwbuf; </span></p>
</div>
<p>Buffers cannot be implicitly nor explicitly cast from one type to
another. This means that local buffers can only be assigned from buffers
with the same element type.</p>
<h3 id="Resources.tybufs.dims">Dimensions[Resources.tybufs.dims]</h3>
<p>The size of a typed buffer can be retrieved using the
<span>GetDimensions</span> method.</p>
<div class="HLSL">
<p>void GetDimensions(out uint width) const;</p>
</div>
<p>This returns the full length, in elements of the buffer through the
<span>width</span> out parameter.</p>
<h3 id="Resources.tybufs.access">Element
Access[Resources.tybufs.access]</h3>
<p>The contents of typed buffers can be retrieved using the
<span>Load</span> methods or the subscript operator.</p>
<div class="HLSL">
<p>T Load(in int index) const; T operator[](int index) const;</p>
</div>
<p>These each return the element of the buffer’s type at the given index
<span>index</span>.</p>
<p>An additional <span>Load</span> method returns the indicated element
just as the other, but also takes a second <span>status</span> parameter
that returns information about the accessed resource.</p>
<div class="HLSL">
<p>T Load(in int index, out uint status) const;</p>
</div>
<p>The <span>status</span> parameter returns an indication of whether
all of the retrieved value came from fully mapped parts of the resource.
This parameter must be passed to the built-in function
<span>CheckAccessFullyMapped</span> (<a href="#Resources.mapcheck"
data-reference-type="ref" data-reference="Resources.mapcheck">9.7</a>)
in order to interpret it.</p>
<p>Writable buffers have an additional subscript operator that allows
assignment to an element of the buffer. It behaves as if it returns a
reference to that element.</p>
<div class="HLSL">
<p>T &amp;operator[](int index);</p>
</div>
<p>Partial writes aren’t allowed. Assignment to individual vector
elements will result in an error.</p>
<h2 id="Resources.rawbufs">Raw Buffers[Resources.rawbufs]</h2>
<p>Raw buffers are one-dimensional resources of arbitrary memory layout.
They are either ByteAddressBuffers or StructuredBuffers.
ByteAddressBuffers enable per-byte access to the raw data while
StructuredBuffers have an associated structure type that determines how
they are indexed. This type can be a scalar, vector, matrix, or
user-defined struct.</p>
<h2 id="Resources.babufs">Byte Access Buffers[Resources.babufs]</h2>
<div class="HLSL">
<p>class ByteAddressBuffer</p>
<p>public: ByteAddressBuffer(); ByteAddressBuffer(const
ByteAddressBuffer &amp;buf); ByteAddressBuffer
&amp;operator=(ByteAddressBuffer &amp;buf);</p>
<p>void GetDimensions(out uint size) const;</p>
<p>// Element access. uint Load(in uint offset) const; uint2 Load2(in
uint offset) const; uint3 Load3(in uint offset) const; uint4 Load4(in
uint offset) const; template&lt;typename T&gt; T Load(in uint offset)
const;</p>
<p>uint Load(in uint offset, out uint status) const; uint2 Load2(in uint
offset, out uint status) const; uint3 Load3(in uint offset, out uint
status) const; uint4 Load4(in uint offset, out uint status) const;
template&lt;typename T&gt; T Load(in uint offset, out uint status)
const;</p>
<p>;</p>
<p>class RWByteAddressBuffer : public ByteAddressBuffer</p>
<p>public: RWByteAddressBuffer(); RWByteAddressBuffer(const
RWByteAddressBuffer &amp;buf); RWByteAddressBuffer
&amp;operator=(RWByteAddressBuffer &amp;buf);</p>
<p>// Element assignment. void Store(in uint offset, in uint value);
void Store2(in uint offset, in uint2 value); void Store3(in uint offset,
in uint3 value); void Store4(in uint offset, in uint4 value);
template&lt;typename T&gt; void Store(in uint offset, in T value);</p>
<p>// 32-bit integer atomic arithmetic/bitwise operations. void
InterlockedAdd(in uint offset, in uint value); void InterlockedAdd(in
uint offset, in uint value, out uint original); void InterlockedAnd(in
uint offset, in uint value); void InterlockedAnd(in uint offset, in uint
value, out uint original); void InterlockedOr(in uint offset, in uint
value); void InterlockedOr(in uint offset, in uint value, out uint
original); void InterlockedXor(in uint offset, in uint value); void
InterlockedXor(in uint offset, in uint value, out uint original);</p>
<p>// 32-bit integer atomic comparison operations void InterlockedMin(in
uint offset, in int value); void InterlockedMin(in uint offset, in uint
value); void InterlockedMin(in uint offset, in int value, out int
original); void InterlockedMin(in uint offset, in uint value, out uint
original); void InterlockedMax(in uint offset, in int value); void
InterlockedMax(in uint offset, in uint value); void InterlockedMax(in
uint offset, in int value, out int original); void InterlockedMax(in
uint offset, in uint value, out uint original);</p>
<p>// 32-bit integer atomic compare/exchange operations void
InterlockedCompareStore(in uint offset, in uint compare, in uint value);
void InterlockedExchange(in uint offset, in uint value, out uint
original); void InterlockedCompareExchange(in uint offset, in uint
compare, in uint value, out uint original);</p>
<p>// 64-bit integer atomic arithmatic/bitwise operations void
InterlockedAdd64(in uint offset, in uint64_t value); void
InterlockedAdd64(in uint offset, in uint64_t value, out uint64_t
original); void InterlockedAnd64(in uint offset, in uint64_t value);
void InterlockedAnd64(in uint offset, in uint64_t value, out uint64_t
original); void InterlockedOr64(in uint offset, in uint64_t value); void
InterlockedOr64(in uint offset, in uint64_t value, out uint64_t
original); void InterlockedXor64(in uint offset, in uint64_t value);
void InterlockedXor64(in uint offset, in uint64_t value, out uint64_t
original);</p>
<p>// 64-bit integer atomic comparison operations void
InterlockedMin64(in uint offset, in int64_t value); void
InterlockedMin64(in uint offset, in int64_t value, out int64_t
original); void InterlockedMin64(in uint offset, in uint64_t value);
void InterlockedMin64(in uint offset, in uint64_t value, out uint64_t
original); void InterlockedMax64(in uint offset, in int64_t value); void
InterlockedMax64(in uint offset, in int64_t value, out int64_t
original); void InterlockedMax64(in uint offset, in uint64_t value);
void InterlockedMax64(in uint offset, in uint64_t value, out uint64_t
original);</p>
<p>// 64-bit integer atomic compare/exchange operations void
InterlockedCompareStore64(in uint offset, in uint64_t compare, in
uint64_t value); void InterlockedExchange64(in uint offset, in int64_t
value, out int64_t original); void InterlockedCompareExchange64(in uint
offset, in uint64_t compare, in uint64_t value, out int64_t
original);</p>
<p>// 32-bit float atomic compare/exchange operations void
InterlockedCompareStoreFloatBitwise(in uint byteOffest, in float
compare, in float value); void InterlockedExchangeFloat(in uint
byteOffest, in float value, out float original); void
InterlockedCompareExchangeFloatBitwise(in uint byteOffest, in float
compare, in float value, out float original);</p>
<p>;</p>
</div>
<h3 id="Resources.babufs.ctrs">Constructors[Resources.babufs.ctrs]</h3>
<p>Since their contents are viewed as raw bytes, ByteAddressBuffers are
defined without any type parameters.</p>
<div class="HLSL">
<p>ByteAddressBuffer robuf; RWByteAddressBuffer rwbuf;</p>
</div>
<p>When defined at global scope, ByteAccessBuffers are bound to
externally-defined backing stores using the explicit binding location if
provided or the implicit binding if not (<a href="#Resources.binding"
data-reference-type="ref"
data-reference="Resources.binding">9.8</a>).</p>
<p>When defined at local scope, ByteAccessBuffers represent local
references that can be associated with global ByteAccessBuffers when
assigned, but must be resolvable to a unique global buffer
declaration.</p>
<div class="HLSL">
<p>ByteAddressBuffer grobuf; RWByteAddressBuffer grwbuf; void main()
<span> ByteAddressBuffer lrobuf = grobuf; RWByteAddressBuffer lrwbuf =
grwbuf; </span></p>
</div>
<h3 id="Resources.babufs.dims">Dimensions[Resources.babufs.dims]</h3>
<p>The size of a ByteAddressBuffer can be retrieved using the
<span>GetDimensions</span> method.</p>
<div class="HLSL">
<p>void GetDimensions(out uint size) const;</p>
</div>
<p>This returns the full size of the buffer in bytes through the
<span>size</span> out parameter.</p>
<h3 id="Resources.babufs.access">Element
Access[Resources.babufs.access]</h3>
<p>The contents of ByteAddressBuffers can be retrieved using the
<span>Load</span> methods.</p>
<div class="HLSL">
<p>uint Load(in uint offset) const; uint2 Load2(in uint offset) const;
uint3 Load3(in uint offset) const; uint4 Load4(in uint offset)
const;</p>
</div>
<p>These each return the bytes at the given byte offset into the buffer
<span>offset</span> in the form of one or more unsigned integers. The
<span>offset</span> address must be a multiple of 4. Each of the
variants returns a number of bytes corresponding to the size of the uint
vector returned.</p>
<p>An additional templated load method allows returning the bytes at the
given byte offset in the form of the type given in the template
parameter. This can be a scalar, vector, matrix, or user-defined
struct.</p>
<div class="HLSL">
<p>template&lt;typename T&gt; T Load(in uint offset) const;</p>
</div>
<p>The alignment requirements of <span>offset</span> for this operation
is the alignment requirement of an object of type <span>T</span> in the
device memory space (<a href="#Intro.Memory.Alignment"
data-reference-type="ref"
data-reference="Intro.Memory.Alignment">1.7.2</a>).</p>
<p>Additional <span>Load</span> methods return the same values as the
others, but also take a second <span>status</span> parameter that
returns information about the accessed resource.</p>
<div class="HLSL">
<p>uint Load(in uint offset, out uint status) const; uint2 Load2(in uint
offset, out uint status) const; uint3 Load3(in uint offset, out uint
status) const; uint4 Load4(in uint offset, out uint status) const;
template&lt;typename T&gt; T Load(in uint offset, out uint status)
const;</p>
</div>
<p>The <span>status</span> parameter returns an indication of whether
all of the retrieved value came from fully mapped parts of the resource.
This parameter must be passed to the built-in function
<span>CheckAccessFullyMapped</span> (<a href="#Resources.mapcheck"
data-reference-type="ref" data-reference="Resources.mapcheck">9.7</a>)
in order to interpret it.</p>
<h3 id="Resources.babufs.atomics">Atomic
Operations[Resources.babufs.atomics]</h3>
<p>RWByteAddressBuffers have a suite of atomic methods that perform the
given operation on type-appropriate-sized element data at the given
buffer offset in a way that ensures no contention from other threads
performing other operations. Each of these operates on two 32 or 64 bit
values: the given parameter value and the buffer value. The buffer value
is a 32 or 64 bit value at a given offset into the buffer. Each method
has an overload that returns the original buffer value before the atomic
operation was performed.</p>
<div class="HLSL">
<p>void InterlockedAdd(in uint offset, in uint value); void
InterlockedAdd(in uint offset, in uint value, out uint original); void
InterlockedAnd(in uint offset, in uint value); void InterlockedAnd(in
uint offset, in uint value, out uint original); void InterlockedOr(in
uint offset, in uint value); void InterlockedOr(in uint offset, in uint
value, out uint original); void InterlockedXor(in uint offset, in uint
value); void InterlockedXor(in uint offset, in uint value, out uint
original);</p>
</div>
<p>Perform atomic addition, bitwise and, bitwise or, or bitwise
exclusive or on the 32-bit integer buffer value at the byte offset
<span>offset</span> and the provided <span>value</span>. Store the
result to that offset buffer location, optionally returning the original
buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedMin(in uint offset, in int value); void
InterlockedMin(in uint offset, in uint value); void InterlockedMin(in
uint offset, in int value, out int original); void InterlockedMin(in
uint offset, in uint value, out uint original); void InterlockedMax(in
uint offset, in int value); void InterlockedMax(in uint offset, in uint
value); void InterlockedMax(in uint offset, in int value, out int
original); void InterlockedMax(in uint offset, in uint value, out uint
original);</p>
</div>
<p>Perform the sign-approrpriate minimum or maximum comparison on the
32-bit integer buffer value at the byte offset <span>offset</span> and
the provided <span>value</span>. Store the lesser or greater value, as
appropriate, to that offset buffer location, optionally returning the
original buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedExchange(in uint offset, in uint value, out uint
original);</p>
</div>
<p>Performs an atomic exchange of the 32-bit integer buffer value at the
byte offset <span>offset</span> with the provided <span>value</span>.
Stores <span>value</span> at the offset buffer location and returns the
original buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedCompareStore(in uint offset, in uint compare, in uint
value); void InterlockedCompareExchange(in uint offset, in uint compare,
in uint value, out uint original);</p>
</div>
<p>Perform an atomic exchange of or store to the 32-bit integer buffer
value at the byte offset <span>offset</span> with the provided
<span>value</span> if the value at that location matches the value of
<span>compare</span>. <span>InterlockedCompareExchange</span> returns
the original buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedAdd64(in uint offset, in uint64_t value); void
InterlockedAdd64(in uint offset, in uint64_t value, out uint64_t
original); void InterlockedAnd64(in uint offset, in uint64_t value);
void InterlockedAnd64(in uint offset, in uint64_t value, out uint64_t
original); void InterlockedOr64(in uint offset, in uint64_t value); void
InterlockedOr64(in uint offset, in uint64_t value, out uint64_t
original); void InterlockedXor64(in uint offset, in uint64_t value);
void InterlockedXor64(in uint offset, in uint64_t value, out uint64_t
original);</p>
</div>
<p>Perform atomic addition, bitwise and, bitwise or, or bitwise
exclusive or on the 64-bit integer buffer value at the byte offset
<span>offset</span> and the provided <span>value</span>. Store the
result to that offset buffer location, optionally returning the original
buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedMin64(in uint offset, in int64_t value); void
InterlockedMin64(in uint offset, in uint64_t value); void
InterlockedMin64(in uint offset, in int64_t value, out int64_t
original); void InterlockedMin64(in uint offset, in uint64_t value, out
uint64_t original); void InterlockedMax64(in uint offset, in int64_t
value); void InterlockedMax64(in uint offset, in uint64_t value); void
InterlockedMax64(in uint offset, in int64_t value, out int64_t
original); void InterlockedMax64(in uint offset, in uint64_t value, out
uint64_t original);</p>
</div>
<p>Perform the sign-approrpriate minimum or maximum comparison on the
64-bit integer buffer value at the byte offset <span>offset</span> and
the provided <span>value</span>. Store the lesser or greater value, as
appropriate, to that offset buffer location, optionally returning the
original buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedExchange64(in uint offset, in uint64_t value, out
uint64_t original);</p>
</div>
<p>Performs an atomic exchange of the 64-bit integer buffer value at the
byte offset <span>offset</span> with the provided <span>value</span>.
Stores <span>value</span> at the offset buffer location and returns the
original buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedCompareStore64(in uint offset, in uint64_t compare,
in uint64_t value); void InterlockedCompareExchange64(in uint offset, in
uint64_t compare, in uint64_t value, out uint64_t original);</p>
</div>
<p>Perform an atomic exchange of or store to the 64-bit integer buffer
value at the byte offset <span>offset</span> with the provided
<span>value</span> if the value at that location matches the value of
<span>compare</span>. <span>InterlockedCompareExchange</span> returns
the original buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedExchangeFloat(in uint byteOffest, in float value, out
float original);</p>
</div>
<p>Performs an atomic exchange of the 32-bit float buffer value at the
byte offset <span>offset</span> with the provided <span>value</span>.
Stores <span>value</span> at the offset buffer location and returns the
original buffer value through <span>original</span>.</p>
<div class="HLSL">
<p>void InterlockedCompareStoreFloatBitwise(in uint byteOffest, in float
compare, in float value); void InterlockedCompareExchangeFloatBitwise(in
uint byteOffest, in float compare, in float value, out float
original);</p>
</div>
<p>Perform an atomic exchange of or store to the 32-bit float buffer
value at the byte offset <span>offset</span> with the provided
<span>value</span> if the value at that location matches the value of
<span>compare</span> in a bitwise comparison.
<span>InterlockedCompareExchangeFloatBitwise</span> returns the original
buffer value through <span>original</span>.</p>
<p>Unlike standard floating point comparisons, values will only match if
the bit representation matches which can miss some matching values that
have different bit repesantations in addition to ignoring floating point
rules surrounding NaN and infinite values.</p>
<h2 id="Resources.stbufs">Structured Buffers[Resources.stbufs]</h2>
<p>Structured buffers are raw buffers with associated types that
facilitate indexing. Unlike typed buffers, they perform no format
conversions. The buffer contents is treated as raw data. Accessors
return the contained bytes as the target type with no conversions or
interpolations applied. Structured buffers can be defined with scalar,
vector, matrix, or user-defined struct elements.</p>
<p>Structured buffers can be read-only, writable, appendable, or
consumable. Writable buffers can have their elements assigned in
arbitrary locations. Append structured buffers can only have elements
added to the end. Consume structured buffers can only have elements
removed from the end.</p>
<div class="HLSL">
<p>template &lt;typename T&gt; class StructuredBuffer</p>
<p>public: StructuredBuffer(); StructuredBuffer(const StructuredBuffer
&amp;buf); StructuredBuffer &amp;operator=(StructuredBuffer
&amp;buf);</p>
<p>void GetDimensions(out uint count, out uint stride) const;</p>
<p>// Element access. T operator[](int index) const; T Load(in int
index) const; T Load(in int index, out uint status) const;</p>
<p>;</p>
<p>template &lt;typename T&gt; class RWStructuredBuffer : public
StructuredBuffer</p>
<p>public: RWStructuredBuffer(); RWStructuredBuffer(const
RWStructuredBuffer &amp;buf); RWStructuredBuffer
&amp;operator=(RWStructuredBuffer &amp;buf);</p>
<p>// Element assignment. T &amp;operator[](int index);</p>
<p>// Hidden counter increment/decrement. uint IncrementCounter(); uint
DecrementCounter();</p>
<p>;</p>
<p>template &lt;typename T&gt; class AppendStructuredBuffer</p>
<p>public: AppendStructuredBuffer(); AppendStructuredBuffer(const
AppendStructuredBuffer &amp;buf); AppendStructuredBuffer
&amp;operator=(AppendStructuredBuffer &amp;buf);</p>
<p>void GetDimensions(out uint count, out uint stride) const;</p>
<p>void Append(in T value);</p>
<p>;</p>
<p>template &lt;typename T&gt; class ConsumeStructuredBuffer</p>
<p>public: ConsumeStructuredBuffer(); ConsumeStructuredBuffer(const
ConsumeStructuredBuffer &amp;buf); ConsumeStructuredBuffer
&amp;operator=(ConsumeStructuredBuffer &amp;buf);</p>
<p>void GetDimensions(out uint count, out uint stride) const;</p>
<p>T Consume();</p>
<p>;</p>
</div>
<h3 id="Resources.stbufs.ctrs">Constructors[Resources.stbufs.ctrs]</h3>
<p>Structured buffers must be defined with explicit template parameter
types.</p>
<div class="HLSL">
<p>struct S <span>int i; float f;</span>; StructuredBuffer&lt;S&gt;
robuf1; StructuredBuffer&lt;float4&gt; robuf2;
StructuredBuffer&lt;float2x3&gt; robuf3;</p>
<p>RWStructuredBuffer&lt;S&gt; rwbuf1; RWStructuredBuffer&lt;float4&gt;
rwbuf2; RWStructuredBuffer&lt;float2x3&gt; rwbuf3;</p>
<p>AppendStructuredBuffer&lt;S&gt; apbuf1;
AppendStructuredBuffer&lt;float4&gt; apbuf2;
AppendStructuredBuffer&lt;float2x3&gt; apbuf3;</p>
<p>ConsumeStructuredBuffer&lt;S&gt; cobuf1;
ConsumeStructuredBuffer&lt;float4&gt; cobuf2;
ConsumeStructuredBuffer&lt;float2x3&gt; cobuf3;</p>
</div>
<p>When defined at global scope, structured buffers are bound to
externally-defined backing stores using the explicit binding location if
provided or the implicit binding if not (<a href="#Resources.binding"
data-reference-type="ref"
data-reference="Resources.binding">9.8</a>).</p>
<p>When defined at local scope, structured buffers represent local
references that can be associated with global buffers when assigned, but
must be resolvable to a unique global buffer declaration.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Resource types contained in structs are
only allocated registers when they are explicitly used. This includes
elements of arrays of resources as such array elements must be indexed
with literals.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<div class="HLSL">
<p>StructuredBuffer&lt;int3x3&gt; grobuf;
RWStructuredBuffer&lt;int3x3&gt; grwbuf;
AppendStructuredBuffer&lt;int3x3&gt; gapbuf;
ConsumeStructuredBuffer&lt;int3x3&gt; gcobuf; void main() <span>
StructuredBuffer&lt;int3x3&gt; lrobuf = grobuf;
RWStructuredBuffer&lt;int3x3&gt; lrwbuf = grwbuf;
AppendStructuredBuffer&lt;int3x3&gt; lbuf = gapbuf;
ConsumeStructuredBuffer&lt;int3x3&gt; lcobuf = gcobuf; </span></p>
</div>
<p>Structured buffer operands to the assignment operator must have the
same element type.</p>
<h3 id="Resources.stbufs.dims">Dimensions[Resources.stbufs.dims]</h3>
<p>The structure count and stride of a structured buffer can be
retrieved using the <span>GetDimensions</span> method.</p>
<div class="HLSL">
<p>void GetDimensions(out uint count, out uint stride);</p>
</div>
<p>This returns number of structured elements of the buffer through the
<span>count</span> out parameter and the size of each element in bytes
through the <span>stride</span> out parameter.</p>
<h3 id="Resources.stbufs.access">Element
Access[Resources.stbufs.access]</h3>
<p>The contents of read-only StructuredBuffers and writable
RWStructuredBuffers can be retrieved using the <span>Load</span> methods
or the subscript operator.</p>
<div class="HLSL">
<p>T Load(in int index) const; T operator[](int index) const;</p>
</div>
<p>These each return the element of the buffer’s type at the given index
<span>index</span>.</p>
<p>An additional <span>Load</span> method returns the indicated element
just as the other, but also takes a second <span>status</span> parameter
that returns information about the accessed resource.</p>
<div class="HLSL">
<p>T Load(in int index, out uint status) const;</p>
</div>
<p>The <span>status</span> parameter returns an indication of whether
all of the retrieved value came from fully mapped parts of the resource.
This parameter must be passed to the built-in function
<span>CheckAccessFullyMapped</span> (<a href="#Resources.mapcheck"
data-reference-type="ref" data-reference="Resources.mapcheck">9.7</a>)
in order to interpret it.</p>
<p>Writable RWStructuredBuffers have an additional subscript operator
that allows assignment to a structure element of the buffer. It behaves
as if it returns a reference to that element.</p>
<div class="HLSL">
<p>T &amp;operator[](int index);</p>
</div>
<h3 id="Resources.stbufs.counter">Counter
Manipulation[Resources.stbufs.counter]</h3>
<p>RWStructuredBuffers may have a hidden counter that can be incremented
and decremented using methods.</p>
<div class="HLSL">
<p>uint IncrementCounter(); uint DecrementCounter();</p>
</div>
<p>Increment or decrements the hidden counter associated with the
RWStructuredBuffer. <span>IncrementCounter</span> returns the
pre-increment value of the counter. <span>DecrementCounter</span>
returns the post-decrement value of the counter.</p>
<h3 id="Resources.stbufs.append">Append[Resources.stbufs.append]</h3>
<p>AppendStructuredBuffers can only be appended to as an output
stream.</p>
<div class="HLSL">
<p>void Append(in T value);</p>
</div>
<p>Appends the <span>value</span> of the template parameter types to the
end of the AppendStructuredBuffer. Subsequent appends will continue to
add elements to the end of the buffer.</p>
<h3
id="Resources.cnstbufs.consume">Consume[Resources.cnstbufs.consume]</h3>
<p>ConsumeStructuredBuffers can only have values pulled from them as an
input stream.</p>
<div class="HLSL">
<p>T Consume();</p>
</div>
<p>Removes and returns a value of the template parameter types from the
end of the ConsumeStructuredBuffer.</p>
<h2 id="Resources.cnbuf">Constant Buffers[Resources.cnbuf]</h2>
<p>Constant buffers represent resources that contain read-only constant
data in a well-defined memory layout.</p>
<h3 id="Resources.cnbuf.cb">Constant Buffer Declaration
Block[Resources.cnbuf.cb]</h3>
<p><strong></strong> A constant buffer can be declared using the
<span>cbuffer</span> specifier.</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>cbuffer-declaration-group</em><span
class="nodecor">:</span></span><br />
* <span>cbuffer</span> name
<span>resource-binding<sub><em>opt</em></sub></span> <span>{</span>
<span>cbuffer-declaration-seq<sub><em>opt</em></sub></span>
<span>}</span></p>
<p><span><em>cbuffer-declaration-seq</em><span
class="nodecor">:</span></span><br />
* <em>cbuffer-declaration</em><br />
* <em>cbuffer-declaration-seq cbuffer-declaration</em></p>
<p><span><em>cbuffer-declaration</em><span
class="nodecor">:</span></span><br />
* <em>variable-declaration</em><br />
* <em>empty-declaration</em></p>
</div>
<p><strong></strong> The name of the <span>cbuffer</span> declaration
group cannot be referenced from within the translation unit and is not
required to be unique.</p>
<p><strong></strong> Variable declarations in the <span>cbuffer</span>
declaration group are called <em>shader constants</em>.</p>
<p><strong></strong> Shader constants can be referenced from anywhere in
the translation unit after they are declared by directly using the
declaration name. This implies that all shader constants declared in a
translation unit must have unique names, even though they might be
declared in different <span>cbuffer</span> declaration groups.</p>
<p><strong></strong> Variable declarations in the <span>cbuffer</span>
declaration group cannot have <span>groupshared</span> or
<span>static</span> variable modifiers.</p>
<p><strong></strong> Other declarations in the <span>cbuffer</span>
declaration group such as <em>namespace-declaration</em>,
<em>record-declaration</em> or <em>function-declaration</em> are not
allowed.</p>
<p><strong></strong> Nesting of <span>cbuffer</span> declaration groups
is not allowed.</p>
<p><strong></strong> For example:</p>
<div class="HLSL">
<p>cbuffer MyConstants <span> float4 CameraPos; </span>;</p>
<p>float4 getCameraPosition() <span> return CameraPos; </span></p>
</div>
<h3 id="Resources.cnbuf.cbclass">Constant Buffer
Class[Resources.cnbuf.cbclass]</h3>
<p><strong></strong> Another way of declaring constant buffers is by
using the <span>ConstantBuffer&lt;T&gt;</span> resource class.</p>
<p><strong></strong> The template parameter <span>T</span> must be a
class type (<a href="#Classes" data-reference-type="ref"
data-reference="Classes">10</a>).</p>
<div class="HLSL">
<p>template &lt;typename T&gt; class ConstantBuffer <span> public:
ConstantBuffer(); ConstantBuffer(const ConstantBuffer &amp;buf);
ConstantBuffer &amp;operator=(ConstantBuffer &amp;buf); </span>;</p>
</div>
<p><strong></strong> The <em>shader constants</em> are the fields of the
class type <span>T</span>. They can be referenced from anywhere within
the translation unit after the <span>ConstantBuffer&lt;T&gt;</span>
declaration as if they were fields of the
<span>ConstantBuffer&lt;T&gt;</span> class.</p>
<p><strong></strong> For example:</p>
<div class="HLSL">
<p>struct MyConstants <span> float4 CameraPos; </span>;</p>
<p>ConstantBuffer&lt;MyConstants&gt; CB;</p>
<p>float4 getCameraPosition() <span> return CB.CameraPos; </span></p>
</div>
<p><strong></strong> The layout rules for constant buffer declared with
the <span>ConstantBuffer&lt;T&gt;</span> syntax are the same as for
named <span>cbuffer</span> declaration groups.</p>
<p><strong></strong> <span>ConstantBuffer&lt;T&gt;</span> can be defined
at local scope to represent a local reference to a constant buffer that
can be associated with a global buffer when assigned. The reference must
be resolvable to a unique global buffer declaration before use.</p>
<p><strong></strong> Constant buffers cannot be implicitly nor
explicitly cast from one type to another. This means that local
<span>ConstantBuffer</span> can only be assigned from
<span>ConstantBuffer</span> with the same template type
<span>T</span>.</p>
<h3 id="Resources.cnbuf.lay">Constant Buffer
Layout[Resources.cnbuf.lay]</h3>
<p><strong></strong> Layout of the constant buffer is implementation
dependent. This section describes the layout that is used by
DirectX.</p>
<p><strong></strong> A constant buffer is arranged like an array of
16-byte rows, or 4-component vectors of 32-bit elements. Shader
constants are arranged into the buffer in the order they were declared
based on following rules.</p>
<p><strong></strong> Specific basic types are packed into the last used
row of the buffer if they fit into the available space, starting at the
next available aligned position. These types include:</p>
<ul>
<li><p><em>scalar types</em></p></li>
<li><p><em>vector types</em></p></li>
<li><p><em>matrix types</em> with only one row in <em>column_major</em>
storage layout</p></li>
</ul>
<p><strong></strong> If they do not fit the remaining space of the row,
they will placed at the start a new 16-byte aligned row.</p>
<p><strong></strong> Vectors are aligned by the size of a single vector
element type unless that alignment results in crossing the 16-byte row
boundary, in which case it is aligned to the next row.</p>
<p><strong></strong> Aggregate types like arrays and structures are
always 16-byte row-aligned. If the aggregate ends with an element that
does not completely fill a row, the remaining space on the last row may
be used by the next value.</p>
<p><strong></strong> Individual array elements are always 16-byte row
aligned.</p>
<p><strong></strong> Matrix types with more than one row in
<em>column_major</em> storage layout and matrix types in
<em>row_major</em> storage layout in are aligned to the 16-byte row.
Each row in storage layout (each column for <em>column_major</em>
matrix) is aligned to a 16-byte row.</p>
<p><strong></strong> Members of structured types used in constant
buffers follow these same rules. Because structures are always 16-byte
row-aligned, the offset layout within the structure is independent of
the particular structure instance location.</p>
<h3 id="Resources.cnbuf.po">Packoffset
annotations[Resources.cnbuf.po]</h3>
<p><strong></strong> Shader constants declared in <span>cbuffer</span>
declaration group can have an optional <span>packoffset</span>
annotation added before their <span>;</span> terminal. If this
annotation is added to one shader constant in a declaration group then
it must be added to all shader constants in that group.</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>packoffset-annotation</em><span
class="nodecor">:</span></span><br />
* <span>: packoffset(</span> packoffset-id packoffset-row
<span>packoffset-element<sub><em>opt</em></sub></span>
<span>)</span></p>
<p><span><em>packoffset-id</em><span
class="nodecor">:</span></span><span class="nodecor">one of</span><br />
* <span>c C</span></p>
<p><span><em>packoffset-row</em><span
class="nodecor">:</span></span><br />
* digit<br />
* packoffset-row digit</p>
<p><span><em>packoffset-element</em><span
class="nodecor">:</span></span><br />
* <span>.</span> <em>packoffset-element-id</em></p>
<p><span><em>packoffset-element-id</em><span
class="nodecor">:</span></span><span class="nodecor">one of</span><br />
* <span>x y z w r g b a</span><br />
*</p>
</div>
<p><strong></strong> The <span>packoffset</span> annotation defines
specific offset in the constant buffer where the shader constant is
located.</p>
<p><strong></strong> The <em>packoffset-row</em> number is the index
into the array of 16-byte rows of the constant buffer. Each row treated
as a vector of four 32-bit elements.</p>
<p><strong></strong> The <em>packoffset-element</em> identifies specific
location within the vector where <span>x</span> or <span>r</span> is the
first element of the vector, <span>y</span> or <span>g</span> is the
second one, <span>z</span> or <span>b</span> is the third one and
<span>w</span> or <span>a</span> is the fourth, and last element of the
vector.</p>
<p><strong></strong> Shader constant that has a structure, array or
matrix type must always be 16-byte row-aligned. It means that if it
specifies a <em>packoffset-element</em>, it must have a value of
<span>x</span> or <span>r</span>.</p>
<p><strong></strong> For example</p>
<div class="HLSL">
<p>cbuffer MyConstants <span> float2 Pos : packoffset(c1.z);
</span>;</p>
</div>
<p>The <span>Pos</span> shader constant will be located at byte offset
in the constant buffer <span>MyConstants</span>.</p>
<h3 id="Resources.cnbuf.defcb">Default Constant
Buffer[Resources.cnbuf.defcb]</h3>
<p><strong></strong> All variables declarations in the global scope are
implicitly added to default constant buffer called
<span>$Globals</span>, unless they are marked <span>static</span>,
<span>groupshared</span>, or declare a resource or array of
resources.</p>
<p><strong></strong> Layout rules for a default constant buffer are the
same as for a named <span>cbuffer</span> declaration group.</p>
<p><strong></strong> Default constant buffer declarations can have an
optional <em>resource-binding</em> annotation with a
<em>register-type</em> <span>c</span> or <span>C</span> added before
their <span>;</span> terminal. This annotation does not define a virtual
register binding but rather an index into an array of 16-byte rows that
represents the default constant buffer, similar to the
<span>packoffset</span> annotation.</p>
<p><strong></strong> For example</p>
<div class="HLSL">
<p>float4 CameraPos : register(c2);</p>
</div>
<p>is equivalent to</p>
<div class="HLSL">
<p>cbuffer CB <span> float4 CameraPos : packoffset(c2); </span></p>
</div>
<h2 id="Resources.samp">Samplers[Resources.samp]</h2>
<h2
id="Resources.mapcheck">CheckAccessFullyMapped[Resources.mapcheck]</h2>
<p>The mapped status value returned by certain texture and buffer
methods can be intrepreted by a built-in function:</p>
<div class="HLSL">
<p>bool CheckAccessFullyMapped(in uint status);</p>
</div>
<p>This function returns true if the value was accessed from a fully
committed resource, or from fully mapped pages of a sparse resource. If
any part of the return value was from unmapped memory, false is
returned.</p>
<h2 id="Resources.binding">Resource Binding[Resources.binding]</h2>
<p>Resources are bound to external memory using virtual registers within
logical registers spaces. These can be specified explicitly using
attributes after the global resource declaration or implicitly by
leaving them off.</p>
<p><em></em></p>
<div class="grammarlist">
<p><span><em>resource-binding</em><span
class="nodecor">:</span></span><br />
* <span>: register(</span> register-type bind-number
<span>)</span><br />
* <span>: register(</span> register-type bind-number ,
<span>space</span> bind-number <span>)</span><br />
* <span><em>register-type</em><span class="nodecor">:</span></span>
<span class="nodecor">one of</span><br />
* <span>t u b s c T U B S C</span><br />
* <span><em>bind-number</em><span class="nodecor">:</span></span><br />
* digit<br />
* bind-number digit<br />
*</p>
</div>
<p>The register type indicates whether the binding is for a read-only
(<span>t</span>/<span>T</span>), a writable
(<span>u</span>/<span>U</span>), a constant buffer
(<span>b</span>/<span>B</span>), or a sampler
(<span>s</span>/<span>S</span>). The register bind number indicates the
register number at which the resource variable begins. The optional
second parameter indicates the virtual register space that the register
belongs to.</p>
<p>Register type <span>c</span>/<span>C</span> defines layout
information for the default constant buffer (<a
href="#Resources.cnbuf.defcb" data-reference-type="ref"
data-reference="Resources.cnbuf.defcb">9.5.5</a>).</p>
<p>Sample syntax of virtual register binding attributes:</p>
<div class="HLSL">
<p>Buffer&lt;float&gt; robuf : register(t0, space0);
RWBuffer&lt;float&gt; rwbuf : register(u0, space0); SamplerState samp :
register(s0, space0); cbuffer cbuf : register(b0, space0) <span> float
f; </span>;</p>
</div>
<p>Each resource must have a unique register. Different resources cannot
occupy the same register, but read-only and writable buffers have
separate namespaces and different logical register spaces have
independent sets of register numbers. Meaning the following is all
allowed:</p>
<div class="HLSL">
<p>Buffer&lt;float&gt; mybuf : register(t0, space0); Buffer&lt;float&gt;
yourbuf : register(t0, space1); RWBuffer&lt;float&gt; hisbuf :
register(u0, space0); RWBuffer&lt;float&gt; herbuf : register(u0,
space1);</p>
</div>
<p>An aggregate resource type can be:</p>
<ul>
<li><p>a struct containing one or more resources types</p></li>
<li><p>an array of resource types</p></li>
<li><p>an array or struct containing either of the above</p></li>
</ul>
<p>Aggregate resource types with register annotations occupy the first
register they specify and however many additional sequential registers
the aggregate requires to assign a register to each of its elements that
correspond to the given register type. Multiple register annotations can
be placed on aggregates involving structs where each corresponds to a
distinct register type that will apply to all the registers of that type
in the aggregate.</p>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Resource types contained in structs are
only allocated registers when they are explicitly used. This includes
elements of arrays of resources since such array elements must be
indexed with literals.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<div class="HLSL">
<p>// Occupies t0, t1, and t2. Buffer&lt;float&gt; fbuf[3] :
register(t0, space0); // Occupies registers t3 - t14. Buffer&lt;int4&gt;
ibuf[4][3] : register(t3, space0); // Occupies registers t15 and u0.
struct <span>RWBuffer&lt;int&gt; rwbuf; Buffer buf;</span> sbufs :
register(t15) : register(u0); // Occupies registers t16 - t21. struct
<span>Buffer bufs[5]; Buffer buf;</span> robufs : register(t16); //
Occupies registers t22-24 and u1-u2 struct <span>Buffer r;
RWBuffer&lt;int&gt; w;</span> bibufs[2] : register(t22) :
register(u1);</p>
</div>
<p>If the register binding or register space is not specified, implicit
values are used. Whenever not specified, the space defaults to
<span>space0</span>.</p>
<div class="HLSL">
<p>Buffer&lt;float2&gt; buf1 : register(t0, space0);
Buffer&lt;float2&gt; buf2 : register(t1); // defaults to space0</p>
</div>
<p>When the register is not specified, resources will recieve
implementation-dependent register assignments.</p>
<h1 id="Classes">Classes[Classes]</h1>
<h2 id="Classes.Static">Static Members[Classes.Static]</h2>
<h2 id="Classes.Conversions">Conversions[Classes.Conversions]</h2>
<h1 id="Template">Templates[Template]</h1>
<h2 id="Template.Inst">Template Instantiation[Template.Inst]</h2>
<h2 id="Template.Func.Order">Partial Ordering of Function
Templates[Template.Func.Order]</h2>
<h1 id="Intangible">Intangible Types[Intangible]</h1>
<h1 id="Runtime">Runtime[Runtime]</h1>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The preprocessor is inherited from C++ 11 with no
grammar extensions. It is specified here only for completeness.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This grammar formulation is not context-free and
requires an LL(2) parser.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This behavior matches <span data-acronym-label="isoC"
data-acronym-form="singular+short">isoC</span> but is reduced in scope
because HLSL has fewer data types.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This substantially deviates from the implementations in
<span data-acronym-label="fxc"
data-acronym-form="singular+abbrv">fxc</span> and <span
data-acronym-label="dxc" data-acronym-form="singular+abbrv">dxc</span>,
but is consistent with the <a
href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers">official
documentation</a> and the behavior of GLSL. It is also substantially
simpler to implement and more regular than the existing behaviors.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>HLSL does not have <span>goto</span>, and labeled
statements are only valid within <span>switch</span> statements.<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Global variable declarations are implicitly constant and
external in HLSL.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>These are not really linked with other translation units
but rather their values are loaded indirectly based on cbuffer
mapping.<a href="#fnref7" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>In DXC today functions that are not entry points or
exported have <em>internal linkage</em> by default. This can be
overriden by <span>-default-linkage</span> compiler option.<a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p><span>sizeof(T)</span> returns the size of the object
as-if it’s stored in device memory, and determining the size if it’s
stored in another memory space is not possible.<a href="#fnref9"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>C23 adopts two’s compliment as the object
representation for integer types.<a href="#fnref10"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>IEEE-754 only defines a binary encoding for 16-bit
floating point values, it does not fully specify the behavior of such
types.<a href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>This means when stored to memory objects of type
<span>min16float</span> are stored as <strong>binary32</strong> as
defined in <span data-acronym-label="IEEE754"
data-acronym-form="singular+short">IEEE754</span>.<a href="#fnref12"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>DXC supports storing objects that contain resources in
cbuffer declarations, but it does so by hoisting the resource
declaration out to the global scope.<a href="#fnref13"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>This differs from C++ with the addition of flat
conversion.<a href="#fnref14" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>C++ does not support dimension altering conversions for
scalar, vector or matrix types.<a href="#fnref15" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p><span data-acronym-label="hlsl"
data-acronym-form="singular+abbrv">hlsl</span> does not support grammar
for specifying pointer or reference types, however they are used in the
type system and must be described in language rules.<a href="#fnref16"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>Array-to-pointer conversion of constant sized arrays is
not supported.<a href="#fnref17" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>This will change in the future, but this document
assumes current behavior.<a href="#fnref18" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>The operand to <span>sizeof(...)</span> is a good
example of an <em>unevaluated operand</em>. In the code
<span>sizeof(Foo())</span>, the call to <span>Foo()</span> is never
evaluated in the program.<a href="#fnref19" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p><a
href="https://github.com/microsoft/hlsl-specs/blob/main/proposals/0007-const-instance-methods.md">HLSL
Specs Proposal 0007</a> proposes adopting C++-like syntax and semantics
for <em>cv-qualified</em> <span>this</span> references.<a
href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21"><p>HLSL does not support the base address of a subscript
operator being the expression inside the braces, which is valid in C and
C++.<a href="#fnref21" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn22"><p>Today in DXC targeting DXIL matches the Microsoft C++
ABI and evaluates argument expressions right-to-left, while SPIR-V
generation matches the Itanium ABI evaluating parameters left-to-right.
There are good arguments for unifying these behaviors, and arguments for
keeping them different.<a href="#fnref22" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn23"><p>This results in <em>input</em> parameters of unsized
arrays being modifiable by a function.<a href="#fnref23"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24"><p>The argument expression is not re-evaluated after the
call, so any side effects of the call occur only before the call.<a
href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25"><p>HLSL <em>output</em> and <em>input/output
parameters</em> are passed by value, so they must also have complete
type.<a href="#fnref25" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn26"><p>As stated above cxvalue parameters are
passed-by-address, so the expiring parameter is the reference to the
address, not the cxvalue. The cxvalue expires in the caller.<a
href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn27"><p>DXC only supports overload resolution for function
calls and invocation of operators during expressions. Clang will support
all contexts listed.<a href="#fnref27" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn28"><p>"Top-level" cv-qualification refers to the
qualification of the value. This means an parameter of type
<span>T</span> can be initialized by a argument of type <span>const
T</span>. This does not mean that a parameter of type <span>inout
T</span> can be initialized with a argument of type <span>const T</span>
because there is no valid inverted conversion system to assign back to a
value of type <span>const T</span>.<a href="#fnref28"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
</body>
</html>
